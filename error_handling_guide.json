{
  "beginner": "## Error Handling Fundamentals\n\n### What Are Exceptions?\n\nExceptions are unexpected events that occur during program execution. They're Python's way of handling errors gracefully instead of crashing.\n\n**Why Error Handling Matters:**\n- Makes programs robust and production-ready\n- Improves user experience with meaningful error messages\n- Prevents data corruption from unexpected failures\n- Allows graceful recovery from problems\n\n```python\n# Without error handling - program crashes\nfile = open('data.txt')  # If file doesn't exist, program stops abruptly\ndata = file.read()\n```\n\n```python\n# With error handling - controlled response\ntry:\n    file = open('data.txt')\n    data = file.read()\nexcept FileNotFoundError:\n    print(\"File not found. Using default data instead.\")\n    data = \"default\"\n```\n\n### Basic Try/Except Syntax\n\nThe try/except block is the foundation of error handling:\n\n```python\ntry:\n    # Code that might cause an error\n    result = 10 / 0\nexcept ZeroDivisionError:\n    # Code that runs if ZeroDivisionError occurs\n    print(\"Cannot divide by zero!\")\n    result = 0\n```\n\n**How it works:**\n1. Python attempts the code in the `try` block\n2. If an exception occurs, it jumps to the matching `except` block\n3. The rest of the try block is skipped\n4. Program continues after the try/except block\n\n```python\nprint(\"Starting\")\ntry:\n    value = int(\"not a number\")\n    print(\"This won't print\")\nexcept ValueError:\n    print(\"Invalid number format\")\nprint(\"Continuing\")\n\n# Output:\n# Starting\n# Invalid number format\n# Continuing\n```\n\n### Understanding Tracebacks\n\nWhen an exception occurs, Python shows a traceback - a report of the error:\n\n```python\nTraceback (most recent call last):\n  File \"script.py\", line 5, in <module>\n    result = 10 / 0\nZeroDivisionError: division by zero\n```\n\n**Reading a traceback:**\n- **File location**: `script.py, line 5` - where the error happened\n- **Code line**: `result = 10 / 0` - the problematic code\n- **Exception type**: `ZeroDivisionError` - what went wrong\n- **Error message**: `division by zero` - why it failed\n\n**Traceback with function calls:**\n\n```python\ndef calculate(divisor):\n    return 10 / divisor\n\ndef process():\n    return calculate(0)\n\nprocess()\n\n# Traceback shows the call chain:\n# File \"script.py\", line 8, in <module>\n#   process()\n# File \"script.py\", line 6, in process\n#   return calculate(0)\n# File \"script.py\", line 3, in calculate\n#   return 10 / divisor\n# ZeroDivisionError: division by zero\n```\n\nRead from bottom to top to find the root cause.\n\n### Common Exception Types\n\n**ValueError**: Wrong value for the operation\n```python\ntry:\n    age = int(\"twenty-five\")\nexcept ValueError:\n    print(\"Age must be a number\")\n```\n\n**TypeError**: Wrong data type\n```python\ntry:\n    result = \"5\" + 10  # Can't add string and int\nexcept TypeError:\n    print(\"Cannot add string and number\")\n```\n\n**KeyError**: Dictionary key doesn't exist\n```python\nuser = {\"name\": \"Alice\", \"email\": \"alice@example.com\"}\n\ntry:\n    phone = user[\"phone\"]  # Key doesn't exist\nexcept KeyError:\n    print(\"Phone number not available\")\n```\n\n**IndexError**: List index out of range\n```python\nitems = [\"apple\", \"banana\", \"cherry\"]\n\ntry:\n    fruit = items[10]  # Index doesn't exist\nexcept IndexError:\n    print(\"No item at that position\")\n```\n\n**FileNotFoundError**: File doesn't exist\n```python\ntry:\n    with open(\"missing.txt\") as f:\n        data = f.read()\nexcept FileNotFoundError:\n    print(\"File does not exist\")\n```\n\n**AttributeError**: Object doesn't have that attribute\n```python\nclass User:\n    def __init__(self, name):\n        self.name = name\n\nuser = User(\"Bob\")\n\ntry:\n    print(user.email)  # Attribute doesn't exist\nexcept AttributeError:\n    print(\"User object has no email attribute\")\n```\n\n### Generic Exception Catching (Use with Caution!)\n\nYou can catch any exception with a bare `except` clause, but this should be rare:\n\n```python\ntry:\n    result = 10 / 0\nexcept:\n    print(\"Something went wrong\")\n```\n\n**Why avoid bare except:**\n- Hides bugs by catching unexpected exceptions\n- Makes debugging harder\n- Catches KeyboardInterrupt (Ctrl+C) unexpectedly\n\n```python\n# Better: catch the base Exception class\ntry:\n    result = 10 / 0\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n```\n\n### Accessing Exception Information\n\nYou can capture the exception object to get details:\n\n```python\ntry:\n    value = int(\"abc\")\nexcept ValueError as error:\n    print(f\"Error type: {type(error).__name__}\")\n    print(f\"Error message: {error}\")\n```\n\n### Key Takeaways\n\n1. **Try/except** catches and handles errors gracefully\n2. **Be specific** about which exceptions you catch\n3. **Read tracebacks** carefully from bottom to top\n4. **Exception types** tell you what went wrong\n5. **Access the error object** with `as variable_name`\n6. Proper error handling makes programs reliable and user-friendly",
  "intermediate": "## Advanced Error Handling Techniques\n\n### Catching Multiple Exceptions\n\nOften you need to handle different exceptions differently:\n\n```python\ntry:\n    file = open(\"data.txt\")\n    data = file.read()\n    numbers = [int(x) for x in data.split(\",\")]\nexcept FileNotFoundError:\n    print(\"File not found\")\n    numbers = []\nexcept ValueError:\n    print(\"Invalid number format in file\")\n    numbers = []\n```\n\n**Multiple exceptions in one handler:**\n\n```python\ntry:\n    result = int(user_input) / divisor\nexcept (ValueError, TypeError):\n    print(\"Please provide valid numbers\")\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero\")\n```\n\n**Decision Tree: Which Exception to Catch?**\n\n```\nDo you know what specific error might occur?\n├─ YES: Catch that specific exception type\n│   └─ Example: FileNotFoundError when opening files\n├─ NO: Can you catch multiple specific types?\n│   └─ YES: Use multiple except clauses\n│   └─ NO: Catch Exception (not bare except)\n└─ NEVER: Use bare except clause - it hides bugs\n```\n\n### The Else Clause\n\nThe `else` block runs **only if no exception occurred**:\n\n```python\ntry:\n    file = open(\"data.txt\")\n    data = file.read()\nexcept FileNotFoundError:\n    print(\"File not found\")\n    data = None\nelse:\n    # Runs only if no exception occurred\n    lines = data.split(\"\\n\")\n    print(f\"Successfully read {len(lines)} lines\")\n```\n\n**Why use else?**\n- Separates error-handling code from success code\n- Makes intent clear\n- Reduces try block scope (better practice)\n\n```python\n# Without else - less clear\ntry:\n    file = open(\"data.txt\")\n    data = file.read()\n    lines = data.split(\"\\n\")  # Processing in try block\n    print(f\"Read {len(lines)} lines\")\nexcept FileNotFoundError:\n    print(\"File not found\")\n\n# With else - clearer separation\ntry:\n    file = open(\"data.txt\")\n    data = file.read()\nexcept FileNotFoundError:\n    print(\"File not found\")\nelse:\n    lines = data.split(\"\\n\")  # Only runs if no error\n    print(f\"Read {len(lines)} lines\")\n```\n\n### The Finally Clause\n\nThe `finally` block **always runs**, whether an exception occurred or not:\n\n```python\ntry:\n    file = open(\"data.txt\")\n    data = file.read()\nexcept FileNotFoundError:\n    print(\"File not found\")\nfinally:\n    # Always runs - perfect for cleanup\n    file.close()\n    print(\"File closed\")\n```\n\n**Why finally is essential:**\n\n```python\n# Without finally - resource leak\ndef read_config():\n    file = open(\"config.txt\")\n    config = file.read()\n    return config  # Oops! File never closes if exception occurs\n\n# With finally - guaranteed cleanup\ndef read_config():\n    file = open(\"config.txt\")\n    try:\n        config = file.read()\n    finally:\n        file.close()  # Always closes, even on exception\n    return config\n```\n\n**Using context managers instead (modern Python):**\n\n```python\n# Best practice - automatic cleanup\nwith open(\"config.txt\") as file:\n    config = file.read()\n# File automatically closes, even on exception\n```\n\n**Try/Except/Else/Finally together:**\n\n```python\ntry:\n    file = open(\"data.txt\")\n    data = file.read()\nexcept FileNotFoundError:\n    print(\"Using default data\")\n    data = \"default\"\nexcept IOError as e:\n    print(f\"Read error: {e}\")\n    data = None\nelse:\n    print(\"Successfully read file\")\nfinally:\n    print(\"Cleanup complete\")\n```\n\n### Raising Exceptions\n\nYou can raise (throw) exceptions when you detect invalid conditions:\n\n```python\ndef validate_age(age):\n    if age < 0:\n        raise ValueError(\"Age cannot be negative\")\n    if age > 150:\n        raise ValueError(\"Age seems unrealistic\")\n    return True\n\ntry:\n    validate_age(-5)\nexcept ValueError as e:\n    print(f\"Invalid age: {e}\")\n```\n\n**Re-raising exceptions:**\n\n```python\ntry:\n    file = open(\"data.txt\")\n    data = file.read()\nexcept FileNotFoundError as e:\n    print(\"Logging error...\")\n    raise  # Re-raise the same exception\n```\n\n**Exception chaining:**\n\n```python\ndef load_data(filename):\n    try:\n        file = open(filename)\n        data = json.load(file)\n    except FileNotFoundError as e:\n        # Chain exceptions - shows original error too\n        raise ValueError(f\"Cannot load {filename}\") from e\n\n# When caught, shows:\n# ValueError: Cannot load data.json\n# The above exception was the direct cause of the following exception:\n# FileNotFoundError: [Errno 2] No such file or directory: 'data.json'\n```\n\n### Logging Exceptions\n\n**Don't use print for errors:**\n\n```python\n# Bad - error buried in regular output\ntry:\n    result = 10 / divisor\nexcept ZeroDivisionError:\n    print(\"ERROR: Division by zero\")  # Goes to console, hard to track\n```\n\n**Use logging instead:**\n\n```python\nimport logging\n\nlogger = logging.getLogger(__name__)\n\ntry:\n    result = 10 / divisor\nexcept ZeroDivisionError:\n    logger.error(\"Division by zero occurred\", exc_info=True)\n    result = 0\n```\n\n**Benefits of logging:**\n- Messages go to log files, not just console\n- Different severity levels (debug, info, warning, error, critical)\n- Can be filtered and formatted\n- `exc_info=True` automatically includes traceback\n\n```python\nimport logging\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(__name__)\n\ntry:\n    data = open(\"missing.txt\").read()\nexcept FileNotFoundError:\n    logger.warning(f\"File not found, using default data\")\n    data = \"default\"\nexcept Exception as e:\n    logger.error(f\"Unexpected error: {e}\", exc_info=True)\n    data = None\n```\n\n### Common Error Handling Patterns\n\n**Pattern 1: EAFP (Easier to Ask for Forgiveness than Permission)**\n\n```python\n# EAFP - Try first\ntry:\n    phone = user[\"phone\"]\nexcept KeyError:\n    phone = \"N/A\"\n```\n\n**Pattern 2: LBYL (Look Before You Leap)**\n\n```python\n# LBYL - Check first\nif \"phone\" in user:\n    phone = user[\"phone\"]\nelse:\n    phone = \"N/A\"\n```\n\n**When to use EAFP (Python style):**\n- Simpler code\n- Handles race conditions better\n- More Pythonic\n\n```python\n# EAFP - recommended in Python\ntry:\n    value = numbers[index]\nexcept IndexError:\n    value = None\n```\n\n**Pattern 3: Context Managers for Resource Management**\n\n```python\n# Automatic cleanup guaranteed\nwith open(\"data.txt\") as file:\n    data = file.read()\n# File automatically closed\n\n# Works with exception handling too\ntry:\n    with open(\"data.txt\") as file:\n        data = file.read()\nexcept FileNotFoundError:\n    data = None\n# File still closes automatically\n```\n\n### Common Pitfalls\n\n**Pitfall 1: Catching too broad**\n\n```python\n# Bad - catches all exceptions, hides bugs\ntry:\n    result = int(user_input)\n    data = users[result]\nexcept:  # Catches everything!\n    print(\"Error\")\n\n# Good - specific exceptions\ntry:\n    result = int(user_input)\nexcept ValueError:\n    print(\"Invalid number\")\n\ntry:\n    data = users[result]\nexcept IndexError:\n    print(\"User not found\")\n```\n\n**Pitfall 2: Silent failures**\n\n```python\n# Bad - silently ignores errors\ntry:\n    process_data(user_input)\nexcept Exception:\n    pass  # User never knows what went wrong\n\n# Good - log or re-raise\ntry:\n    process_data(user_input)\nexcept ValueError as e:\n    logger.error(f\"Invalid data: {e}\")\n    # Optional: re-raise if caller should know\n    raise\n```\n\n**Pitfall 3: Not closing resources**\n\n```python\n# Bad - file not closed on error\nfile = open(\"data.txt\")\ndata = file.read()\nfile.close()\n\n# Good - guaranteed cleanup\ntry:\n    file = open(\"data.txt\")\n    data = file.read()\nfinally:\n    file.close()\n\n# Best - context manager\nwith open(\"data.txt\") as file:\n    data = file.read()\n```\n\n### Exception Hierarchies\n\nExceptions inherit from base classes:\n\n```\nBaseException\n├── KeyboardInterrupt (Ctrl+C)\n├── SystemExit (exit())\n└── Exception (most normal exceptions)\n    ├── ValueError\n    ├── TypeError\n    ├── KeyError\n    ├── IndexError\n    ├── FileNotFoundError\n    ├── AttributeError\n    ├── ArithmeticError\n    │   └── ZeroDivisionError\n    └── ...\n```\n\n**Catching by hierarchy:**\n\n```python\n# Catches IndexError, KeyError, ValueError, etc.\ntry:\n    value = users[index][\"name\"]\nexcept (IndexError, KeyError) as e:\n    print(f\"Access error: {e}\")\n\n# Catches all normal exceptions\ntry:\n    risky_operation()\nexcept Exception as e:\n    print(f\"Something went wrong: {e}\")\n\n# Never catch BaseException (includes KeyboardInterrupt, SystemExit)\ntry:  # Bad!\n    while True:\n        pass\nexcept BaseException:\n    pass  # Can't interrupt with Ctrl+C\n```\n\n### Key Takeaways\n\n1. **Be specific** about which exceptions to catch\n2. **Use else** to separate success logic from error handling\n3. **Use finally** or context managers for cleanup\n4. **Log exceptions** with proper logging module\n5. **Raise exceptions** to signal problems in your code\n6. **Use EAFP** for Pythonic error handling\n7. **Avoid broad exception catching** - it hides bugs",
  "advanced": "## Professional Error Handling\n\n### Custom Exceptions\n\nCreate custom exception classes for your application's specific errors:\n\n```python\n# Define custom exceptions\nclass ValidationError(Exception):\n    \"\"\"Raised when user input validation fails\"\"\"\n    pass\n\nclass DatabaseError(Exception):\n    \"\"\"Raised when database operations fail\"\"\"\n    pass\n\nclass APIError(Exception):\n    \"\"\"Raised when external API calls fail\"\"\"\n    pass\n\n# Using custom exceptions\ndef create_user(name, email, age):\n    if not name or not email:\n        raise ValidationError(\"Name and email are required\")\n    if age < 18:\n        raise ValidationError(\"User must be 18 or older\")\n    if not save_to_db(name, email, age):\n        raise DatabaseError(\"Failed to save user\")\n    return True\n\ntry:\n    create_user(\"\", \"test@example.com\", 25)\nexcept ValidationError as e:\n    print(f\"Invalid input: {e}\")\nexcept DatabaseError as e:\n    print(f\"Database error: {e}\")\n```\n\n**Creating exception hierarchies:**\n\n```python\n# Base exception for your application\nclass AppError(Exception):\n    \"\"\"Base exception for the application\"\"\"\n    pass\n\n# Specific exceptions inherit from base\nclass ConfigError(AppError):\n    \"\"\"Configuration-related errors\"\"\"\n    pass\n\nclass NetworkError(AppError):\n    \"\"\"Network-related errors\"\"\"\n    pass\n\nclass ValidationError(AppError):\n    \"\"\"Validation-related errors\"\"\"\n    pass\n\n# Now you can catch all app errors or specific ones\ntry:\n    complex_operation()\nexcept AppError as e:  # Catches any app-specific error\n    logger.error(f\"Application error: {e}\")\nexcept ConfigError as e:  # Catches only config errors\n    logger.error(f\"Configuration problem: {e}\")\n```\n\n**Custom exceptions with additional context:**\n\n```python\nclass DatabaseError(Exception):\n    \"\"\"Custom exception with extra information\"\"\"\n    def __init__(self, message, error_code=None, query=None):\n        self.message = message\n        self.error_code = error_code\n        self.query = query\n        super().__init__(self.message)\n    \n    def __str__(self):\n        return f\"{self.message} (Code: {self.error_code})\"\n\ntry:\n    result = execute_query(\"SELECT * FROM users\")\nexcept DatabaseError as e:\n    logger.error(f\"DB Error: {e}\")\n    logger.debug(f\"Failed query: {e.query}\")\n    logger.debug(f\"Error code: {e.error_code}\")\n```\n\n**When to create custom exceptions:**\n\n```\nDo you need domain-specific error handling?\n├─ YES: Create custom exception\n│   ├─ Authentication failures → AuthenticationError\n│   ├─ Payment processing → PaymentError\n│   ├─ API-specific errors → APIError\n│   └─ Business logic violations → BusinessLogicError\n├─ NO: Use built-in exceptions\n│   ├─ Value problems → ValueError\n│   ├─ Type problems → TypeError\n│   ├─ Missing keys → KeyError\n│   └─ Missing files → FileNotFoundError\n```\n\n### Exception Context\n\n**Understanding exception chaining:**\n\n```python\n# Explicit chaining - shows cause\ntry:\n    file = open(\"config.json\")\n    config = json.load(file)\nexcept FileNotFoundError as e:\n    raise ConfigError(\"Cannot load configuration\") from e\n\n# Implicit chaining - happens automatically\ntry:\n    result = int(data)  # ValueError\nexcept ValueError:\n    # Raising during exception handling automatically chains\n    raise ProcessingError(\"Failed to process data\")\n\n# The traceback shows both:\n# ProcessingError: Failed to process data\n# The above exception was the direct cause of the following exception:\n# ValueError: invalid literal for int()\n```\n\n**Suppressing exception context when not relevant:**\n\n```python\n# Sometimes chaining adds noise\ntry:\n    old_connection.close()\nexcept Exception:\n    pass  # Old connection close failure is expected\n\n# Suppress the context if it's not helpful\ntry:\n    old_connection.close()\nexcept Exception as e:\n    raise ConnectionError(\"Failed to establish connection\") from None\n    # 'from None' says: this isn't caused by the previous exception\n```\n\n### Exception Context Managers\n\nCreate reusable exception handling patterns:\n\n```python\nfrom contextlib import contextmanager\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@contextmanager\ndef handle_errors(operation_name):\n    \"\"\"Context manager for standard error handling\"\"\"\n    try:\n        yield\n    except Exception as e:\n        logger.error(f\"Error during {operation_name}: {e}\", exc_info=True)\n        raise\n\n# Usage\nwith handle_errors(\"database insert\"):\n    insert_user(user_data)\n\nwith handle_errors(\"API call\"):\n    response = requests.get(url)\n```\n\n**Advanced context manager with cleanup:**\n\n```python\n@contextmanager\ndef database_transaction(connection):\n    \"\"\"Ensure transaction commits or rolls back\"\"\"\n    try:\n        yield connection\n        connection.commit()\n    except Exception as e:\n        connection.rollback()\n        logger.error(f\"Transaction failed: {e}\")\n        raise\n\n# Usage - automatic commit/rollback\nwith database_transaction(conn) as db:\n    db.insert(\"users\", user_data)\n    db.insert(\"logs\", log_entry)  # If this fails, both roll back\n```\n\n### Best Practices\n\n**1. Fail Fast, Fail Explicitly**\n\n```python\n# Bad - silent failure, fails later in unrelated code\ndef process_payment(amount):\n    if amount <= 0:\n        return False  # Silent failure\n    return charge_card(amount)\n\n# Good - fail immediately with clear error\ndef process_payment(amount):\n    if amount <= 0:\n        raise ValueError(\"Amount must be positive\")\n    return charge_card(amount)\n\n# Caller gets immediate feedback\ntry:\n    process_payment(-100)\nexcept ValueError as e:\n    print(f\"Invalid amount: {e}\")  # Clear error immediately\n```\n\n**2. Catch at the Right Level**\n\n```python\n# Bad - catching at too low a level\ndef get_user_count():\n    try:\n        with open(\"users.db\") as f:\n            return len(f.readlines())\n    except FileNotFoundError:\n        return 0  # Not the responsibility of this function\n\n# Good - let exceptions bubble up\ndef get_user_count():\n    with open(\"users.db\") as f:\n        return len(f.readlines())\n\n# Handle at the appropriate level (main, API handler, etc.)\ntry:\n    count = get_user_count()\nexcept FileNotFoundError:\n    logger.error(\"User database not found\")\n    count = 0\n```\n\n**3. Use Exception Information Effectively**\n\n```python\n# Bad - losing information\ntry:\n    process_data(user_input)\nexcept Exception:\n    print(\"Error\")  # What error? Where? When?\n\n# Good - capture context\ntry:\n    process_data(user_input)\nexcept ValueError as e:\n    logger.error(\n        \"Invalid user input\",\n        exc_info=True,  # Includes traceback\n        extra={\n            \"user_id\": current_user.id,\n            \"input\": user_input,\n            \"timestamp\": datetime.now()\n        }\n    )\n```\n\n**4. Provide Helpful Error Messages**\n\n```python\n# Bad - vague error message\nraise ValueError(\"Invalid value\")\n\n# Good - specific error message\nraise ValueError(\n    f\"Age must be between 0 and 150, got {age}\"\n)\n\n# Better - include context\nraise ValueError(\n    f\"Invalid user age: {age}. Expected integer between 0-150. \"\n    f\"Provided value: {repr(age_input)} (type: {type(age_input).__name__})\"\n)\n```\n\n**5. Use Type Hints with Exceptions**\n\n```python\nfrom typing import Optional\n\ndef parse_integer(value: str) -> int:\n    \"\"\"Parse string to integer.\n    \n    Args:\n        value: String representation of integer\n    \n    Returns:\n        Parsed integer value\n    \n    Raises:\n        ValueError: If string is not a valid integer\n    \"\"\"\n    try:\n        return int(value)\n    except ValueError as e:\n        raise ValueError(f\"Cannot parse '{value}' as integer\") from e\n\ndef find_user(user_id: int) -> Optional[User]:\n    \"\"\"Find user by ID.\n    \n    Args:\n        user_id: User ID to search for\n    \n    Returns:\n        User object if found, None otherwise\n    \n    Raises:\n        DatabaseError: If database query fails\n    \"\"\"\n    try:\n        return database.query(User).filter_by(id=user_id).first()\n    except DatabaseException as e:\n        raise DatabaseError(\"Failed to query database\") from e\n```\n\n### Anti-Patterns to Avoid\n\n**Anti-Pattern 1: Bare Except**\n\n```python\n# NEVER DO THIS\ntry:\n    critical_operation()\nexcept:\n    pass\n\n# Catches KeyboardInterrupt, SystemExit, and masks bugs\n# User can't interrupt (Ctrl+C doesn't work)\n# Bugs silently fail\n\n# If you must catch everything:\ntry:\n    critical_operation()\nexcept Exception as e:  # Better\n    logger.error(f\"Operation failed: {e}\")\n```\n\n**Anti-Pattern 2: Catching Exception in Library Code**\n\n```python\n# BAD - library code catching broadly\ndef parse_data(data):\n    try:\n        return json.loads(data)\n    except Exception:  # This hides bugs in caller's code\n        return None\n\n# GOOD - specific exceptions, let others bubble up\ndef parse_data(data):\n    try:\n        return json.loads(data)\n    except json.JSONDecodeError:\n        raise ValueError(f\"Invalid JSON: {data}\") from e\n    except TypeError as e:\n        raise TypeError(f\"Expected string, got {type(data)}\") from e\n```\n\n**Anti-Pattern 3: Not Preserving Original Exception**\n\n```python\n# Bad - original exception lost\ntry:\n    connect_to_database()\nexcept Exception:\n    raise RuntimeError(\"Database connection failed\")  # Original lost\n\n# Good - chain exceptions to preserve context\ntry:\n    connect_to_database()\nexcept Exception as e:\n    raise RuntimeError(\"Database connection failed\") from e\n    # Now traceback shows original error too\n```\n\n**Anti-Pattern 4: Over-Broad Except Blocks**\n\n```python\n# Bad - tries to handle multiple unrelated errors in one block\ntry:\n    value = int(user_input)\n    result = data[value]\n    file = open(result)\nexcept:  # Handles ValueError, IndexError, AND FileNotFoundError\n    print(\"Something failed\")  # Which error? Who knows!\n\n# Good - separate concerns\ntry:\n    value = int(user_input)\nexcept ValueError:\n    print(\"Invalid number\")\n    return\n\ntry:\n    result = data[value]\nexcept IndexError:\n    print(\"Index out of range\")\n    return\n\ntry:\n    file = open(result)\nexcept FileNotFoundError:\n    print(\"File not found\")\n```\n\n**Anti-Pattern 5: Using Exceptions for Flow Control**\n\n```python\n# Bad - exceptions as flow control (very slow)\ndef find_item(items, target):\n    try:\n        for i in range(len(items)):\n            if items[i] == target:\n                return i\n        raise StopIteration()  # Ugly!\n    except StopIteration:\n        return -1\n\n# Good - normal flow control\ndef find_item(items, target):\n    for i, item in enumerate(items):\n        if item == target:\n            return i\n    return -1\n\n# Or use built-in\ntry:\n    return items.index(target)\nexcept ValueError:\n    return -1\n```\n\n**Anti-Pattern 6: Resource Leaks**\n\n```python\n# Bad - file never closes on exception\ndef read_file(path):\n    file = open(path)\n    data = file.read()  # Exception here leaves file open\n    file.close()\n    return data\n\n# Good - guaranteed closure\ndef read_file(path):\n    try:\n        file = open(path)\n        return file.read()\n    finally:\n        file.close()\n\n# Best - context manager\ndef read_file(path):\n    with open(path) as file:\n        return file.read()\n```\n\n### Performance Considerations\n\n**Exception handling performance:**\n\n```python\n# Exceptions are NOT free, but cost is negligible in normal cases\n\n# Creating exception: ~1 microsecond (insignificant)\n# Raising/catching: ~10 microseconds (negligible for most code)\n# Only matters if raising thousands per second\n\n# DO use exceptions for normal error handling\ntry:\n    result = int(user_input)\nexcept ValueError:\n    result = 0  # Normal, fine performance\n\n# DON'T use exceptions as flow control in tight loops\n# Bad - thousands of exceptions per second\nfor i in range(1000000):\n    try:\n        x = items[i]\n    except IndexError:\n        break  # Slow if items is short\n\n# Good - normal flow control\nfor i, x in enumerate(items):\n    pass  # Fast\n```\n\n### Production Error Handling\n\n**Structured error response:**\n\n```python\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nclass ErrorType(Enum):\n    VALIDATION_ERROR = \"validation_error\"\n    NOT_FOUND = \"not_found\"\n    DATABASE_ERROR = \"database_error\"\n    INTERNAL_ERROR = \"internal_error\"\n\n@dataclass\nclass ErrorResponse:\n    type: ErrorType\n    message: str\n    code: int\n    details: dict = None\n\ndef api_handler(request):\n    try:\n        user_data = validate_user(request.data)\n        user = create_user(**user_data)\n        return {\"status\": \"success\", \"user_id\": user.id}, 201\n    except ValidationError as e:\n        return {\n            \"type\": ErrorType.VALIDATION_ERROR.value,\n            \"message\": str(e),\n            \"code\": 400\n        }, 400\n    except DatabaseError as e:\n        logger.error(f\"Database error: {e}\", exc_info=True)\n        return {\n            \"type\": ErrorType.DATABASE_ERROR.value,\n            \"message\": \"Database operation failed\",\n            \"code\": 500\n        }, 500\n    except Exception as e:\n        logger.error(f\"Unexpected error: {e}\", exc_info=True)\n        return {\n            \"type\": ErrorType.INTERNAL_ERROR.value,\n            \"message\": \"Internal server error\",\n            \"code\": 500\n        }, 500\n```\n\n### Key Takeaways\n\n1. **Create custom exceptions** for domain-specific errors\n2. **Chain exceptions** with `from` to preserve context\n3. **Fail fast and explicitly** with clear error messages\n4. **Catch at appropriate levels** - not too broad, not too narrow\n5. **Preserve exception information** for debugging\n6. **Use context managers** for resource cleanup\n7. **Avoid exception anti-patterns** that hide bugs or leak resources\n8. **Log exceptions properly** with context for production debugging\n9. **Document exceptions** your functions can raise\n10. **Never use bare except** or catch Exception in library code lightly",
  "cheatsheet": "## Error Handling Quick Reference\n\n### Basic Syntax\n\n```python\n# Simple try/except\ntry:\n    risky_code()\nexcept SpecificError:\n    handle_error()\n\n# With error object\ntry:\n    value = int(user_input)\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n\n# Multiple exceptions\ntry:\n    process_data()\nexcept (ValueError, KeyError):\n    print(\"Bad value or missing key\")\n\n# With else (runs if no exception)\ntry:\n    file = open(\"data.txt\")\nexcept FileNotFoundError:\n    print(\"Not found\")\nelse:\n    data = file.read()  # Only if no exception\n\n# With finally (always runs)\ntry:\n    operation()\nexcept Error:\n    handle_error()\nfinally:\n    cleanup()  # Always executes\n\n# Context manager (automatic cleanup)\nwith open(\"file.txt\") as f:\n    data = f.read()\n```\n\n### Common Exceptions\n\n```python\nValueError          # Wrong value: int(\"abc\")\nTypeError           # Wrong type: \"5\" + 10\nKeyError            # Missing key: dict[\"missing\"]\nIndexError          # Bad index: list[999]\nFileNotFoundError   # Missing file: open(\"none.txt\")\nAttributeError      # Missing attribute: obj.missing\nZeroDivisionError   # Divide by zero: 10/0\nNameError           # Undefined variable: undefined_var\nIOError             # File/IO problem\nTimeoutError        # Operation timed out\nRuntimeError        # Generic runtime error\n```\n\n### Exception Hierarchy Quick Decision\n\n```\nValue problems?           → ValueError\nType problems?            → TypeError\nMissing key?              → KeyError\nMissing index?            → IndexError\nMissing file?             → FileNotFoundError\nMissing attribute?        → AttributeError\nDivision by zero?         → ZeroDivisionError\nNetwork/timeout issues?   → TimeoutError\nUnknown?                  → Exception (last resort)\n\nNEVER use bare except!\n```\n\n### Raising Exceptions\n\n```python\n# Simple raise\nif age < 0:\n    raise ValueError(\"Age cannot be negative\")\n\n# Raise with message\nif not config:\n    raise ConfigError(f\"Missing config: {path}\")\n\n# Re-raise current exception\ntry:\n    risky_operation()\nexcept Error:\n    log_error()\n    raise  # Re-raise same exception\n\n# Chaining (show cause)\ntry:\n    open(\"file.txt\")\nexcept FileNotFoundError as e:\n    raise DataError(\"Cannot load data\") from e\n\n# Suppress chaining (not caused by)\ntry:\n    cleanup_old_resource()\nexcept:\n    raise NewError(\"Failed\") from None\n```\n\n### Custom Exceptions\n\n```python\n# Simple custom exception\nclass ValidationError(Exception):\n    pass\n\n# With additional info\nclass APIError(Exception):\n    def __init__(self, message, status_code):\n        self.message = message\n        self.status_code = status_code\n        super().__init__(message)\n\n# Exception hierarchy\nclass AppError(Exception):\n    pass\n\nclass DatabaseError(AppError):\n    pass\n\nclass ValidationError(AppError):\n    pass\n\n# Usage\nraise ValidationError(\"Invalid input\")\n```\n\n### Logging vs Print\n\n```python\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n# BAD - print\ntry:\n    operation()\nexcept Error:\n    print(\"Error occurred\")  # Disappears in logs\n\n# GOOD - logging\ntry:\n    operation()\nexcept Error:\n    logger.error(\"Operation failed\", exc_info=True)\n    # exc_info=True includes full traceback\n\n# With context\ntry:\n    operation()\nexcept Error as e:\n    logger.error(\n        \"Operation failed\",\n        exc_info=True,\n        extra={\"user_id\": user.id, \"operation\": \"delete\"}\n    )\n\n# Log levels\nlogger.debug(\"Detailed info\")\nlogger.info(\"General info\")\nlogger.warning(\"Something might be wrong\")\nlogger.error(\"Something went wrong\")\nlogger.critical(\"System is in serious trouble\")\n```\n\n### EAFP vs LBYL Patterns\n\n```python\n# EAFP - Pythonic style\ntry:\n    value = dictionary[key]\nexcept KeyError:\n    value = default\n\n# LBYL - Alternative\nif key in dictionary:\n    value = dictionary[key]\nelse:\n    value = default\n\n# EAFP - Preferred in Python\ntry:\n    item = items[index]\nexcept IndexError:\n    item = None\n\n# Context manager - Best for resources\nwith open(\"file.txt\") as f:\n    data = f.read()\n```\n\n### Resource Management Patterns\n\n```python\n# Manual cleanup (risky)\nfile = open(\"data.txt\")\ntry:\n    data = file.read()\nfinally:\n    file.close()\n\n# Context manager (safe)\nwith open(\"data.txt\") as file:\n    data = file.read()\n\n# Database transaction pattern\nwith db.transaction():\n    db.insert(table, record1)\n    db.insert(table, record2)\n    # Commits if no exception, rolls back on exception\n\n# Custom context manager\nfrom contextlib import contextmanager\n\n@contextmanager\ndef error_handler(name):\n    try:\n        yield\n    except Exception as e:\n        logger.error(f\"Error in {name}: {e}\")\n        raise\n\nwith error_handler(\"database_insert\"):\n    insert_record(data)\n```\n\n### Anti-Patterns to Avoid\n\n```python\n# ❌ Bare except\ntry:\n    code()\nexcept:  # NEVER!\n    pass\n\n# ❌ Silent failures\ntry:\n    risky_operation()\nexcept:\n    pass  # Who knows what failed?\n\n# ❌ Catching too broad\ntry:\n    a = int(input)  # ValueError\n    b = items[a]    # IndexError  \n    c = b.method()  # AttributeError\nexcept Exception:   # Catches all, hard to debug\n    pass\n\n# ❌ Resource leak\nfile = open(\"data.txt\")\ndata = file.read()  # Exception here leaves file open\nfile.close()\n\n# ❌ Exception as flow control\nfor i in range(len(items)):\n    try:\n        x = items[i]\n    except IndexError:\n        break  # Inefficient\n\n# ✅ Correct approaches\ntry:\n    specific_error()\nexcept SpecificError as e:  # Specific exception\n    logger.error(f\"Known error: {e}\")  # Log it\n    raise  # Re-raise if needed\nfinally:\n    cleanup()  # Guaranteed cleanup\n```\n\n### Error Handling Flow\n\n```\n┌─ Exception occurs?\n│  ├─ YES: Check exception type\n│  │  ├─ Known type? Catch it specifically\n│  │  └─ Unknown? Log and re-raise\n│  └─ NO: Execute else block\n└─ Always: Run finally block\n\n┌─ Decide what to catch\n│  ├─ Know the error? Catch that type\n│  ├─ Multiple types? Catch in tuple (Error1, Error2)\n│  └─ Multiple errors? Separate try blocks\n└─ Be specific - avoid broad Exception catches\n\n┌─ Decide what to do\n│  ├─ Can recover? Handle and continue\n│  ├─ Should tell caller? Raise new exception\n│  ├─ Need cleanup? Use finally or with\n│  └─ Debug info? Log with exc_info=True\n```\n\n### Reading Tracebacks\n\n```python\nTraceback (most recent call last):\n  File \"script.py\", line 15, in <module>\n    result = divide(10, 0)\n  File \"script.py\", line 3, in divide\n    return a / b\nZeroDivisionError: division by zero\n\n# Read from bottom to top:\n# 1. Exception type: ZeroDivisionError\n# 2. Direct cause: division by zero\n# 3. Where it happened: line 3, divide function\n# 4. Who called it: line 15, main code\n```\n\n### Quick Reference - What to Catch\n\n```python\n# File operations\ntry:\n    with open(path) as f:\n        data = f.read()\nexcept FileNotFoundError:\n    data = None\n\n# Type conversions  \ntry:\n    value = int(user_input)\nexcept ValueError:\n    value = 0\n\n# Dictionary/list access\ntry:\n    item = items[key]\nexcept (KeyError, IndexError):\n    item = None\n\n# Attribute access\ntry:\n    result = obj.attribute\nexcept AttributeError:\n    result = None\n\n# Network operations\ntry:\n    response = requests.get(url, timeout=5)\nexcept (ConnectionError, TimeoutError):\n    response = None\n\n# JSON parsing\ntry:\n    data = json.loads(json_string)\nexcept json.JSONDecodeError:\n    data = {}\n\n# Database operations\ntry:\n    db.insert(table, record)\nexcept DatabaseError as e:\n    logger.error(f\"Insert failed: {e}\")\n```\n\n### Common Defensive Patterns\n\n```python\n# Get with default\nvalue = data.get(key, default)\n# vs\ntry:\n    value = data[key]\nexcept KeyError:\n    value = default\n\n# Check before accessing\nif isinstance(obj, str):\n    length = len(obj)\n# vs\ntry:\n    length = len(obj)\nexcept TypeError:\n    length = None\n\n# Validate input first\nif not validate(data):\n    raise ValueError(\"Invalid data\")\nprocess(data)\n# vs\ntry:\n    process(data)\nexcept ValueError:\n    handle_error()\n\n# Get or create\nif key not in cache:\n    cache[key] = compute_value()\nresult = cache[key]\n# vs\ntry:\n    result = cache[key]\nexcept KeyError:\n    result = compute_value()\n    cache[key] = result\n```\n\n### One-Liners for Common Cases\n\n```python\n# Safe int conversion\nvalue = int(s) if s.isdigit() else 0\n\n# Safe dict get\nvalue = d.get(key, default)\n\n# Safe list access  \nitem = lst[i] if i < len(lst) else None\n\n# Safe attribute get\nattr = getattr(obj, 'attr', default)\n\n# Safe JSON parse\ndata = json.loads(s) if s else {}\n\n# Safe operation with logging\nresult = operation() if validate() else logger.error(\"Invalid\") or None\n```\n"
}
