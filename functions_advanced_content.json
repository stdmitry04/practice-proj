{
  "beginner": "## Functions Advanced: Beginner Level\n\n### 1. Function Definition and Parameters\n\n#### Basic Function Definition\n\nA function is a reusable block of code that performs a specific task.\n\n```python\n# Basic function definition\ndef greet():\n    print(\"Hello, World!\")\n\ngreet()  # Call the function\n# Output: Hello, World!\n```\n\n#### Parameters and Arguments\n\nParameters are variables in the function definition. Arguments are values passed when calling the function.\n\n```python\n# Function with parameters\ndef greet(name):\n    print(f\"Hello, {name}!\")\n\ngreet(\"Alice\")  # \"Alice\" is the argument\n# Output: Hello, Alice!\n\n# Multiple parameters\ndef add(a, b):\n    return a + b\n\nresult = add(5, 3)\nprint(result)  # Output: 8\n```\n\n### 2. Return Values\n\nFunctions return values using the `return` keyword.\n\n```python\n# Function with return value\ndef multiply(x, y):\n    return x * y\n\nproduct = multiply(4, 5)\nprint(product)  # Output: 20\n\n# Return multiple values (as tuple)\ndef get_coordinates():\n    return 10, 20\n\nx, y = get_coordinates()\nprint(x, y)  # Output: 10 20\n\n# Function without explicit return (returns None)\ndef no_return():\n    print(\"This function returns None\")\n\nresult = no_return()\nprint(result)  # Output: None\n```\n\n### 3. Positional and Keyword Parameters\n\n#### Positional Parameters\n\nArguments matched by position.\n\n```python\ndef describe_person(name, age, city):\n    print(f\"{name} is {age} years old and lives in {city}\")\n\ndescribe_person(\"Bob\", 30, \"New York\")  # Positional\n# Output: Bob is 30 years old and lives in New York\n```\n\n#### Keyword Parameters\n\nArguments matched by name.\n\n```python\ndescribe_person(age=30, city=\"New York\", name=\"Bob\")  # Keyword\n# Output: Bob is 30 years old and lives in New York\n\n# Mix positional and keyword\ndescribe_person(\"Bob\", age=30, city=\"New York\")\n# Output: Bob is 30 years old and lives in New York\n```\n\n### 4. Default Parameters\n\nParameters can have default values.\n\n```python\ndef greet(name=\"Guest\"):\n    print(f\"Hello, {name}!\")\n\ngreet()  # Uses default\n# Output: Hello, Guest!\n\ngreet(\"Alice\")  # Overrides default\n# Output: Hello, Alice!\n\n# Multiple defaults\ndef create_profile(name, age=18, city=\"Unknown\"):\n    return f\"{name}, {age}, {city}\"\n\nprint(create_profile(\"John\"))  # age and city use defaults\n# Output: John, 18, Unknown\n\nprint(create_profile(\"Jane\", 25))  # city uses default\n# Output: Jane, 25, Unknown\n```\n\n### 5. Understanding Scope (LEGB Rule)\n\nScope determines where a variable can be accessed.\n\n#### Local Scope\n\nVariables defined inside a function.\n\n```python\ndef local_example():\n    x = 10  # Local variable\n    print(x)  # Can access inside function\n\nlocal_example()  # Output: 10\n# print(x)  # Error! x not accessible outside function\n```\n\n#### Global Scope\n\nVariables defined outside all functions.\n\n```python\nx = 100  # Global variable\n\ndef global_example():\n    print(x)  # Can access global variable\n\nglobal_example()  # Output: 100\nprint(x)  # Output: 100\n```\n\n#### The LEGB Rule\n\nPython searches for variables in this order:\n1. **Local** - Inside current function\n2. **Enclosing** - In outer functions (for nested functions)\n3. **Global** - At module level\n4. **Built-in** - Python's built-in names\n\n```python\nx = \"Global\"\n\ndef outer():\n    x = \"Enclosing\"\n    \n    def inner():\n        x = \"Local\"\n        print(x)  # Prints Local\n    \n    inner()\n    print(x)  # Prints Enclosing\n\nouter()\nprint(x)  # Prints Global\n```\n\n#### The `global` Keyword\n\nModify global variables inside functions.\n\n```python\ncounter = 0\n\ndef increment():\n    global counter  # Declare we're using global variable\n    counter += 1\n\nincrement()\nincrement()\nprint(counter)  # Output: 2\n```\n\n### 6. Common Mistakes\n\n#### Mistake 1: Forgetting to Return\n\n```python\n# Wrong\ndef calculate(a, b):\n    a + b  # Does nothing!\n\nresult = calculate(5, 3)\nprint(result)  # Output: None\n\n# Correct\ndef calculate(a, b):\n    return a + b\n\nresult = calculate(5, 3)\nprint(result)  # Output: 8\n```\n\n#### Mistake 2: Scope Confusion\n\n```python\n# Wrong - local variable shadows global\nx = 10\n\ndef modify_x():\n    x = 5  # Creates local x, doesn't modify global\n    print(x)  # Output: 5\n\nmodify_x()\nprint(x)  # Output: 10 (unchanged!)\n\n# Correct - use global keyword\nx = 10\n\ndef modify_x():\n    global x\n    x = 5\n\nmodify_x()\nprint(x)  # Output: 5\n```\n\n### 7. Why This Matters\n\n- Functions make code reusable and organized\n- Understanding parameters helps you write flexible functions\n- Scope prevents variables from interfering with each other\n- Return values let functions communicate data back to the caller\n\n### Practice Exercises\n\n1. Write a function that takes a name and returns a formatted greeting\n2. Create a function with default parameters for a birthday calculator\n3. Write a function that modifies a global counter\n4. Explain what happens when you call a function without a return statement",
  "intermediate": "## Functions Advanced: Intermediate Level\n\n### 1. *args (Variable Positional Arguments)\n\nAccept any number of positional arguments.\n\n```python\n# Basic *args\ndef print_all(*args):\n    for arg in args:\n        print(arg)\n\nprint_all(1, 2, 3, \"hello\")  # Can pass any number of arguments\n# Output:\n# 1\n# 2\n# 3\n# hello\n\n# *args is a tuple\ndef sum_all(*numbers):\n    total = 0\n    for num in numbers:\n        total += num\n    return total\n\nprint(sum_all(1, 2, 3, 4, 5))  # Output: 15\n\n# Combine with regular parameters\ndef greet_all(greeting, *names):\n    for name in names:\n        print(f\"{greeting}, {name}!\")\n\ngreet_all(\"Hello\", \"Alice\", \"Bob\", \"Charlie\")\n# Output:\n# Hello, Alice!\n# Hello, Bob!\n# Hello, Charlie!\n```\n\n### 2. **kwargs (Variable Keyword Arguments)\n\nAccept any number of keyword arguments.\n\n```python\n# Basic **kwargs\ndef print_info(**kwargs):\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nprint_info(name=\"Alice\", age=30, city=\"NYC\")\n# Output:\n# name: Alice\n# age: 30\n# city: NYC\n\n# **kwargs is a dictionary\ndef create_config(**options):\n    config = {\"debug\": False, \"timeout\": 30}\n    config.update(options)\n    return config\n\nresult = create_config(debug=True, timeout=60)\nprint(result)  # Output: {'debug': True, 'timeout': 60}\n```\n\n### 3. Combining *args and **kwargs\n\n```python\n# Must be in order: args, then kwargs\ndef flexible_function(*args, **kwargs):\n    print(f\"Positional arguments: {args}\")\n    print(f\"Keyword arguments: {kwargs}\")\n\nflexible_function(1, 2, 3, name=\"Alice\", age=30)\n# Output:\n# Positional arguments: (1, 2, 3)\n# Keyword arguments: {'name': 'Alice', 'age': 30}\n\n# Real-world example: logger\ndef log_message(level, *messages, **options):\n    prefix = options.get('prefix', '')\n    separator = options.get('separator', ' ')\n    \n    message = separator.join(str(m) for m in messages)\n    print(f\"[{level}] {prefix}{message}\")\n\nlog_message(\"INFO\", \"User\", \"logged\", \"in\", prefix=\"App: \", separator=\"_\")\n# Output: [INFO] App: User_logged_in\n```\n\n### 4. Type Hints (Function Signatures)\n\nAnnotate parameters and return types.\n\n```python\n# Basic type hints\ndef add(a: int, b: int) -> int:\n    return a + b\n\nresult = add(5, 3)  # Type hint shows we expect integers\nprint(result)  # Output: 8\n\n# Multiple types\nfrom typing import Union, List\n\ndef process_data(value: Union[int, str]) -> str:\n    return str(value)\n\n# List of specific type\ndef sum_numbers(numbers: List[int]) -> int:\n    return sum(numbers)\n\nprint(sum_numbers([1, 2, 3, 4]))  # Output: 10\n\n# Optional parameters\nfrom typing import Optional\n\ndef greet(name: str, greeting: Optional[str] = None) -> str:\n    if greeting is None:\n        greeting = \"Hello\"\n    return f\"{greeting}, {name}!\"\n\nprint(greet(\"Alice\"))  # Output: Hello, Alice!\nprint(greet(\"Bob\", \"Hi\"))  # Output: Hi, Bob!\n\n# Function type hint\nfrom typing import Callable\n\ndef apply_operation(a: int, b: int, operation: Callable[[int, int], int]) -> int:\n    return operation(a, b)\n\ndef multiply(x: int, y: int) -> int:\n    return x * y\n\nprint(apply_operation(5, 3, multiply))  # Output: 15\n```\n\n### 5. Introduction to Decorators\n\nDecorators modify or enhance functions without changing their code.\n\n#### Simple Decorator\n\n```python\n# Basic decorator\ndef my_decorator(func):\n    def wrapper():\n        print(\"Before function call\")\n        func()\n        print(\"After function call\")\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    print(\"Hello!\")\n\nsay_hello()\n# Output:\n# Before function call\n# Hello!\n# After function call\n\n# Without @ syntax (equivalent)\ndef say_hello():\n    print(\"Hello!\")\n\nsay_hello = my_decorator(say_hello)\nsay_hello()\n```\n\n#### Decorator with Arguments\n\n```python\n# Decorator that accepts arguments from the decorated function\ndef add_greeting(greeting):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            print(f\"{greeting}!\")\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator\n\n@add_greeting(\"Welcome\")\ndef process():\n    print(\"Processing data...\")\n\nprocess()\n# Output:\n# Welcome!\n# Processing data...\n\n# Real-world example: logging decorator\ndef log_calls(func):\n    def wrapper(*args, **kwargs):\n        print(f\"Calling {func.__name__} with args={args}, kwargs={kwargs}\")\n        result = func(*args, **kwargs)\n        print(f\"{func.__name__} returned {result}\")\n        return result\n    return wrapper\n\n@log_calls\ndef multiply(a, b):\n    return a * b\n\nmultiply(5, 3)\n# Output:\n# Calling multiply with args=(5, 3), kwargs={}\n# multiply returned 15\n```\n\n### 6. Closures\n\nFunctions that capture variables from their enclosing scope.\n\n```python\n# Basic closure\ndef outer(x):\n    def inner():\n        return x * 2\n    return inner\n\nfunc = outer(5)\nprint(func())  # Output: 10\n\n# Closure captures the variable, not just the value\ndef make_multiplier(n):\n    def multiplier(x):\n        return x * n\n    return multiplier\n\ntimes_three = make_multiplier(3)\ntimes_five = make_multiplier(5)\n\nprint(times_three(10))  # Output: 30\nprint(times_five(10))  # Output: 50\n\n# Practical example: counter factory\ndef make_counter():\n    count = 0\n    \n    def increment():\n        nonlocal count  # Modify enclosing scope variable\n        count += 1\n        return count\n    \n    def get_count():\n        return count\n    \n    return increment, get_count\n\ninc, get = make_counter()\nprint(inc())  # Output: 1\nprint(inc())  # Output: 2\nprint(get())  # Output: 2\n\n# Each call to make_counter creates separate closure\ninc2, get2 = make_counter()\nprint(inc2())  # Output: 1 (separate counter)\nprint(get())   # Output: 2 (original counter unchanged)\n```\n\n### 7. The `nonlocal` Keyword\n\nModify variables in the enclosing scope.\n\n```python\ndef outer():\n    x = 10\n    \n    def inner():\n        nonlocal x  # Access enclosing scope variable\n        x += 5\n        return x\n    \n    result = inner()\n    print(f\"x in outer: {x}\")  # Output: 15 (modified by inner)\n    return result\n\nouter()\n\n# Without nonlocal\ndef outer_wrong():\n    x = 10\n    \n    def inner():\n        x = 5  # Creates new local variable\n        return x\n    \n    print(inner())  # Output: 5\n    print(x)  # Output: 10 (unchanged)\n\nouter_wrong()\n```\n\n### 8. Common Mistakes\n\n#### Mistake 1: Mutable Default Arguments\n\n```python\n# WRONG - mutable default is shared across calls\ndef add_item(item, items=[]):\n    items.append(item)\n    return items\n\nlist1 = add_item(1)\nlist2 = add_item(2)\nprint(list1)  # Output: [1, 2] - UNEXPECTED!\nprint(list2)  # Output: [1, 2] - Same list!\n\n# CORRECT - use None and create new list\ndef add_item(item, items=None):\n    if items is None:\n        items = []\n    items.append(item)\n    return items\n\nlist1 = add_item(1)\nlist2 = add_item(2)\nprint(list1)  # Output: [1]\nprint(list2)  # Output: [2]\n```\n\n#### Mistake 2: Scope Confusion with Closures\n\n```python\n# WRONG - closure captures variable reference, not value\nfunctions = []\nfor i in range(3):\n    functions.append(lambda: i)  # All lambdas capture same 'i'\n\nprint([f() for f in functions])  # Output: [2, 2, 2] - UNEXPECTED!\n\n# CORRECT - use default parameter to capture value\nfunctions = []\nfor i in range(3):\n    functions.append(lambda x=i: x)  # Default parameter captures current value\n\nprint([f() for f in functions])  # Output: [0, 1, 2]\n```\n\n### 9. Why This Matters\n\n- *args and **kwargs make functions incredibly flexible\n- Type hints improve code readability and enable IDE support\n- Decorators are fundamental to Python frameworks like Flask and Django\n- Closures are essential for functional programming patterns\n- Understanding scope prevents subtle bugs that are hard to debug\n\n### Practice Exercises\n\n1. Write a function using *args that returns the average of numbers\n2. Create a function using **kwargs that builds a URL query string\n3. Write a simple timing decorator that measures function execution time\n4. Create a closure that generates unique IDs\n5. Explain why mutable defaults are dangerous",
  "advanced": "## Functions Advanced: Advanced Level\n\n### 1. Deep Dive into Closures and Scope\n\n#### Understanding Cell Variables\n\n```python\n# Closures store cell variables, not direct values\ndef make_adder(x):\n    def add(y):\n        return x + y  # x is a cell variable\n    return add\n\nadd_five = make_adder(5)\nprint(add_five(10))  # Output: 15\n\n# Inspect closure\nprint(add_five.__closure__)  # Shows cell objects\nprint(add_five.__closure__[0].cell_contents)  # Output: 5\n\n# Multiple closures sharing same outer scope\ndef make_functions():\n    operations = []\n    \n    for i in range(3):\n        def operation(x, n=i):  # Default parameter captures current i\n            return x + n\n        operations.append(operation)\n    \n    return operations\n\nops = make_functions()\nprint(ops[0](10))  # Output: 10\nprint(ops[1](10))  # Output: 11\nprint(ops[2](10))  # Output: 12\n```\n\n#### Closure Memory Behavior\n\n```python\n# Closures hold references to entire scope\ndef outer():\n    large_data = [0] * 1000000  # Large list\n    \n    def inner():\n        return 42  # Doesn't use large_data\n    \n    return inner\n\nfunc = outer()\n# func still holds reference to large_data (memory leak risk)\n\n# Solution: explicitly remove reference\ndef outer_safe():\n    large_data = [0] * 1000000\n    \n    def inner():\n        return 42\n    \n    del large_data  # Release memory\n    return inner\n```\n\n#### Function Attributes and Introspection\n\n```python\ndef greet(name: str) -> str:\n    \"\"\"Greet a person by name.\"\"\"\n    return f\"Hello, {name}!\"\n\n# Function attributes\nprint(greet.__name__)  # Output: greet\nprint(greet.__doc__)   # Output: Greet a person by name.\nprint(greet.__annotations__)  # Output: {'name': <class 'str'>, 'return': <class 'str'>}\nprint(greet.__code__.co_varnames)  # Output: ('name',)\nprint(greet.__code__.co_argcount)   # Output: 1\n\n# Custom attributes\ngreet.calls = 0\ndef track_calls(func):\n    def wrapper(*args, **kwargs):\n        func.calls += 1\n        return func(*args, **kwargs)\n    return wrapper\n\n@track_calls\ndef add(a, b):\n    return a + b\n\nadd(1, 2)\nadd(3, 4)\nprint(add.calls)  # Output: 2\n```\n\n### 2. Advanced Decorator Patterns\n\n#### Preserving Function Metadata with functools.wraps\n\n```python\nimport functools\n\n# Without functools.wraps - loses metadata\ndef bad_decorator(func):\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n    return wrapper\n\n@bad_decorator\ndef original():\n    \"\"\"Original function.\"\"\"\n    pass\n\nprint(original.__name__)  # Output: wrapper (WRONG!)\nprint(original.__doc__)   # Output: None (WRONG!)\n\n# With functools.wraps - preserves metadata\ndef good_decorator(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n    return wrapper\n\n@good_decorator\ndef original():\n    \"\"\"Original function.\"\"\"\n    pass\n\nprint(original.__name__)  # Output: original (CORRECT)\nprint(original.__doc__)   # Output: Original function. (CORRECT)\n```\n\n#### Decorator Stacking\n\n```python\n# Decorators applied bottom-to-top\ndef log_decorator(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        print(f\"Calling {func.__name__}\")\n        result = func(*args, **kwargs)\n        print(f\"Returned {result}\")\n        return result\n    return wrapper\n\ndef timer_decorator(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        import time\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        print(f\"Took {end - start:.4f} seconds\")\n        return result\n    return wrapper\n\n@timer_decorator\n@log_decorator\ndef slow_function():\n    import time\n    time.sleep(0.1)\n    return \"Done\"\n\nslow_function()\n# Output:\n# Calling slow_function\n# Returned Done\n# Took 0.1234 seconds\n```\n\n#### Class-Based Decorators\n\n```python\nclass CallCounter:\n    def __init__(self, func):\n        self.func = func\n        self.count = 0\n        functools.update_wrapper(self, func)\n    \n    def __call__(self, *args, **kwargs):\n        self.count += 1\n        print(f\"Call #{self.count}\")\n        return self.func(*args, **kwargs)\n\n@CallCounter\ndef greet(name):\n    return f\"Hello, {name}!\"\n\ngreet(\"Alice\")  # Output: Call #1\ngreet(\"Bob\")    # Output: Call #2\nprint(greet.count)  # Output: 2\n\n# Parameterized class decorator\nclass RateLimiter:\n    def __init__(self, max_calls, timeout):\n        self.max_calls = max_calls\n        self.timeout = timeout\n        self.calls = []\n    \n    def __call__(self, func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            import time\n            now = time.time()\n            # Remove old calls outside timeout\n            self.calls = [t for t in self.calls if now - t < self.timeout]\n            \n            if len(self.calls) >= self.max_calls:\n                raise Exception(f\"Rate limit exceeded: {self.max_calls} calls per {self.timeout}s\")\n            \n            self.calls.append(now)\n            return func(*args, **kwargs)\n        return wrapper\n\n@RateLimiter(max_calls=3, timeout=1)\ndef api_call():\n    print(\"API called\")\n\nfor _ in range(3):\n    api_call()  # Works\n\ntry:\n    api_call()  # Raises exception\nexcept Exception as e:\n    print(e)\n```\n\n### 3. Generators and yield\n\n#### Basic Generator Concept\n\n```python\n# Regular function returns all at once\ndef list_range(n):\n    result = []\n    for i in range(n):\n        result.append(i)\n    return result\n\nprint(list_range(3))  # Output: [0, 1, 2]\n\n# Generator yields one at a time\ndef gen_range(n):\n    for i in range(n):\n        yield i\n\ngen = gen_range(3)\nprint(next(gen))  # Output: 0\nprint(next(gen))  # Output: 1\nprint(next(gen))  # Output: 2\n# print(next(gen))  # StopIteration exception\n\n# Iterate over generator\nfor value in gen_range(3):\n    print(value)  # Output: 0, 1, 2\n```\n\n#### Generator Memory Efficiency\n\n```python\n# Memory comparison\nimport sys\n\n# List: creates entire list in memory\ndef create_large_list(n):\n    return [i**2 for i in range(n)]\n\nlist_result = create_large_list(1000000)\nprint(f\"List size: {sys.getsizeof(list_result)} bytes\")\n\n# Generator: lazy evaluation\ndef create_large_generator(n):\n    for i in range(n):\n        yield i**2\n\ngen_result = create_large_generator(1000000)\nprint(f\"Generator size: {sys.getsizeof(gen_result)} bytes\")  # Much smaller!\n\n# Only compute what you need\nfor i, value in enumerate(gen_result):\n    if i > 5:  # Stop early\n        break\n    print(value)\n```\n\n#### Generator Expressions\n\n```python\n# List comprehension - creates list\nlist_comp = [x**2 for x in range(1000000)]\n\n# Generator expression - lazy evaluation\ngen_expr = (x**2 for x in range(1000000))\n\nprint(type(list_comp))  # Output: <class 'list'>\nprint(type(gen_expr))   # Output: <class 'generator'>\n\n# Usage difference\nprint(sum(list_comp))  # Sums all elements\nprint(sum(gen_expr))   # Computes on the fly\n\n# Generator in function call\nprint(sum(x**2 for x in range(100)))  # Efficient\n```\n\n#### Advanced Generator Patterns\n\n```python\n# Generator with send() for two-way communication\ndef echo():\n    while True:\n        value = yield\n        print(f\"Received: {value}\")\n\ngen = echo()\nnext(gen)  # Start generator\ngen.send(\"Hello\")  # Send value\ngen.send(\"World\")\n\n# Generator pipeline\ndef gen_numbers(n):\n    for i in range(n):\n        yield i\n\ndef double(numbers):\n    for n in numbers:\n        yield n * 2\n\ndef filter_odd(numbers):\n    for n in numbers:\n        if n % 2 == 0:\n            yield n\n\nresult = filter_odd(double(gen_numbers(5)))\nprint(list(result))  # Output: [0, 4, 8]\n\n# Infinite generator\ndef infinite_counter(start=0):\n    n = start\n    while True:\n        yield n\n        n += 1\n\ncounter = infinite_counter()\nprint(next(counter))  # Output: 0\nprint(next(counter))  # Output: 1\nprint(next(counter))  # Output: 2\n```\n\n### 4. Recursion: Deep Understanding\n\n#### Recursion Basics\n\n```python\n# Simple recursion: factorial\ndef factorial(n):\n    if n <= 1:  # Base case\n        return 1\n    return n * factorial(n - 1)  # Recursive case\n\nprint(factorial(5))  # Output: 120\n\n# Recursion with multiple base cases\ndef fibonacci(n):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    return fibonacci(n - 1) + fibonacci(n - 2)\n\nprint(fibonacci(6))  # Output: 8\n```\n\n#### Stack Overflow Risk\n\n```python\nimport sys\n\n# Check recursion limit\nprint(sys.getrecursionlimit())  # Default: 1000\n\n# Deep recursion causes stack overflow\ndef bad_recursion(n):\n    if n == 0:\n        return 0\n    return 1 + bad_recursion(n - 1)\n\n# This works\nprint(bad_recursion(100))\n\n# This fails (RecursionError)\n# print(bad_recursion(2000))\n\n# Increase recursion limit (use carefully)\nsys.setrecursionlimit(5000)\nprint(bad_recursion(2000))  # Now works\n```\n\n#### Tail Recursion and Optimization\n\n```python\n# Regular recursion - inefficient\ndef factorial_regular(n):\n    if n <= 1:\n        return 1\n    return n * factorial_regular(n - 1)\n\n# Tail recursion - more efficient\ndef factorial_tail(n, acc=1):\n    if n <= 1:\n        return acc\n    return factorial_tail(n - 1, n * acc)  # Tail call\n\nprint(factorial_tail(5))  # Output: 120\n\n# Python doesn't optimize tail recursion, but pattern is important\n# Note: Use iteration for efficiency in Python\ndef factorial_iterative(n):\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\n```\n\n#### Memoization for Efficiency\n\n```python\n# Naive fibonacci - exponential time\ndef fib_naive(n):\n    if n <= 1:\n        return n\n    return fib_naive(n - 1) + fib_naive(n - 2)\n\n# print(fib_naive(35))  # Very slow!\n\n# Memoization with decorator\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef fib_memo(n):\n    if n <= 1:\n        return n\n    return fib_memo(n - 1) + fib_memo(n - 2)\n\nprint(fib_memo(35))  # Output: 9227465 (fast!)\n\n# Manual memoization\ndef fib_manual():\n    cache = {}\n    \n    def fib(n):\n        if n in cache:\n            return cache[n]\n        if n <= 1:\n            return n\n        result = fib(n - 1) + fib(n - 2)\n        cache[n] = result\n        return result\n    \n    return fib\n\nfib = fib_manual()\nprint(fib(35))  # Output: 9227465\n```\n\n### 5. Performance: Time Complexity and Optimization\n\n#### Time Complexity Analysis\n\n```python\n# O(1) - Constant time\ndef get_first(items):\n    return items[0]  # Always 1 operation\n\n# O(n) - Linear time\ndef find_sum(items):\n    total = 0\n    for item in items:  # Iterates n times\n        total += item\n    return total\n\n# O(n²) - Quadratic time\ndef bubble_sort(items):\n    n = len(items)\n    for i in range(n):  # n iterations\n        for j in range(n - 1):  # n iterations per i\n            if items[j] > items[j + 1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n    return items\n\n# O(log n) - Logarithmic time\ndef binary_search(items, target):\n    left, right = 0, len(items) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if items[mid] == target:\n            return mid\n        elif items[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\n# O(n log n) - Linearithmic time (efficient sorting)\ndef merge_sort(items):\n    if len(items) <= 1:\n        return items\n    \n    mid = len(items) // 2\n    left = merge_sort(items[:mid])\n    right = merge_sort(items[mid:])\n    \n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n```\n\n#### Performance Optimization Techniques\n\n```python\nimport time\n\n# 1. Use generators instead of lists\ndef slow_process(n):\n    items = [i**2 for i in range(n)]  # Creates full list\n    return sum(items)\n\ndef fast_process(n):\n    items = (i**2 for i in range(n))  # Generator\n    return sum(items)\n\nstart = time.time()\nresult1 = slow_process(1000000)\nprint(f\"List: {time.time() - start:.4f}s\")\n\nstart = time.time()\nresult2 = fast_process(1000000)\nprint(f\"Generator: {time.time() - start:.4f}s\")\n\n# 2. Early exit from loops\ndef find_target_slow(items, target):\n    count = 0\n    for item in items:\n        if item == target:\n            count += 1\n    return count > 0\n\ndef find_target_fast(items, target):\n    for item in items:\n        if item == target:\n            return True  # Exit early\n    return False\n\n# 3. Use built-in functions (C implementations)\ndef sum_slow(items):\n    total = 0\n    for item in items:\n        total += item\n    return total\n\ndef sum_fast(items):\n    return sum(items)  # Built-in is faster\n\n# 4. Memoization for repeated calculations\nfrom functools import lru_cache\n\ndef expensive_calculation(n):\n    if n <= 1:\n        return n\n    return expensive_calculation(n - 1) + expensive_calculation(n - 2)\n\n@lru_cache(maxsize=128)\ndef efficient_calculation(n):\n    if n <= 1:\n        return n\n    return efficient_calculation(n - 1) + efficient_calculation(n - 2)\n\n# 5. Avoid unnecessary function calls in loops\ndef slow_loop():\n    items = range(1000)\n    result = 0\n    for item in items:\n        result += len(str(item))  # Function call each iteration\n    return result\n\ndef fast_loop():\n    items = range(1000)\n    str_len = len  # Cache function reference\n    result = 0\n    for item in items:\n        result += str_len(str(item))\n    return result\n```\n\n#### Profiling and Benchmarking\n\n```python\nimport cProfile\nimport timeit\n\n# Using timeit for simple benchmarks\ndef test_function():\n    return sum(range(1000))\n\ntime_taken = timeit.timeit(test_function, number=10000)\nprint(f\"Time per call: {time_taken / 10000:.6f} seconds\")\n\n# Using cProfile for detailed analysis\ndef fibonacci_slow(n):\n    if n <= 1:\n        return n\n    return fibonacci_slow(n - 1) + fibonacci_slow(n - 2)\n\ncProfile.run('fibonacci_slow(20)')\n# Shows function call counts and time spent\n```\n\n### 6. First-Class Functions and Higher-Order Functions\n\n```python\n# Functions as objects\ndef add(a, b):\n    return a + b\n\ndef multiply(a, b):\n    return a * b\n\noperations = [add, multiply]  # Store functions in list\n\nfor op in operations:\n    print(op(5, 3))  # Output: 8, then 15\n\n# Higher-order functions: take functions as arguments\ndef apply_twice(func, value):\n    return func(func(value))\n\ndef increment(x):\n    return x + 1\n\nprint(apply_twice(increment, 5))  # Output: 7\n\n# Functions that return functions\ndef create_multiplier(factor):\n    def multiplier(x):\n        return x * factor\n    return multiplier\n\ntimes_ten = create_multiplier(10)\nprint(times_ten(5))  # Output: 50\n\n# map, filter, reduce with functions\nvalues = [1, 2, 3, 4, 5]\n\n# map applies function to each element\nsquared = list(map(lambda x: x**2, values))\nprint(squared)  # Output: [1, 4, 9, 16, 25]\n\n# filter keeps elements where function returns True\nevens = list(filter(lambda x: x % 2 == 0, values))\nprint(evens)  # Output: [2, 4]\n\n# reduce applies function cumulatively\nfrom functools import reduce\ntotal = reduce(lambda x, y: x + y, values)\nprint(total)  # Output: 15\n```\n\n### 7. Why This Matters\n\n- Deep understanding of closures enables sophisticated functional programming\n- Advanced decorators are used in every major Python framework\n- Generators dramatically improve memory efficiency at scale\n- Memoization and optimization patterns solve real performance problems\n- First-class functions unlock functional programming paradigms\n- Time complexity understanding prevents algorithmic disasters\n\n### Practice Exercises\n\n1. Create a decorator that caches function results (memoization)\n2. Write a generator that yields fibonacci numbers indefinitely\n3. Implement a decorator that retries a function on failure\n4. Create a function pipeline using generators and decorators\n5. Profile two implementations and explain time complexity differences",
  "cheatsheet": "## Functions Advanced: Cheatsheet\n\n### Function Definition Quick Reference\n\n```python\n# Basic function\ndef function_name(parameters):\n    return value\n\n# With default parameters\ndef function(a, b=10):\n    return a + b\n\n# With *args (variable positional)\ndef function(*args):\n    for arg in args:\n        print(arg)\n\n# With **kwargs (variable keyword)\ndef function(**kwargs):\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\n# Combined: positional, default, *args, **kwargs\ndef function(a, b=10, *args, **kwargs):\n    pass\n```\n\n### Parameters Pattern Quick Reference\n\n| Pattern | Syntax | Example | Use Case |\n|---------|--------|---------|----------|\n| Positional | `def f(a, b):` | `f(1, 2)` | Fixed number of required arguments |\n| Keyword | `def f(a, b):` | `f(b=2, a=1)` | Named arguments for clarity |\n| Default | `def f(a, b=10):` | `f(1)` | Optional parameters with defaults |\n| *args | `def f(*args):` | `f(1, 2, 3)` | Variable number of positional args |\n| **kwargs | `def f(**kwargs):` | `f(a=1, b=2)` | Variable number of keyword args |\n| Keyword-only | `def f(a, *, b):` | `f(1, b=2)` | Force argument to be keyword |\n| Positional-only | `def f(a, /, b):` | `f(1, 2)` | Force argument to be positional (Python 3.8+) |\n\n### Type Hints Quick Reference\n\n```python\nfrom typing import List, Dict, Tuple, Union, Optional, Callable, Any\n\n# Basic types\ndef function(x: int, y: str) -> bool:\n    pass\n\n# Collections\ndef function(items: List[int]) -> Dict[str, int]:\n    pass\n\n# Union (multiple types)\ndef function(value: Union[int, str]) -> None:\n    pass\n\n# Optional (Union with None)\ndef function(name: Optional[str] = None) -> str:\n    pass\n\n# Callable (function as parameter)\ndef function(callback: Callable[[int], str]) -> None:\n    pass\n\n# Any (no type checking)\ndef function(data: Any) -> Any:\n    pass\n\n# Tuple with specific types\ndef function() -> Tuple[int, str, bool]:\n    return (1, \"text\", True)\n```\n\n### Scope (LEGB) Quick Reference\n\n```python\n# LEGB Rule: Local -> Enclosing -> Global -> Built-in\n\nGLOBAL_VAR = \"global\"\n\ndef outer():\n    enclosing_var = \"enclosing\"\n    \n    def inner():\n        local_var = \"local\"\n        print(GLOBAL_VAR, enclosing_var, local_var)\n    \n    inner()\n\n# Access global variable\nprint(GLOBAL_VAR)\n\n# Modify global variable\ndef modify_global():\n    global GLOBAL_VAR\n    GLOBAL_VAR = \"modified\"\n\n# Modify enclosing variable (in nested function)\ndef outer2():\n    count = 0\n    \n    def inner():\n        nonlocal count\n        count += 1\n        return count\n    \n    return inner\n\nfunc = outer2()\nprint(func())  # 1\nprint(func())  # 2\n```\n\n### Closures Quick Reference\n\n```python\n# Basic closure\ndef make_adder(x):\n    def add(y):\n        return x + y  # Captures x\n    return add\n\nadd_five = make_adder(5)\nprint(add_five(10))  # 15\n\n# Closure with state\ndef counter():\n    count = 0\n    \n    def increment():\n        nonlocal count\n        count += 1\n        return count\n    \n    def get_count():\n        return count\n    \n    return increment, get_count\n\ninc, get = counter()\nprint(inc())  # 1\nprint(inc())  # 2\nprint(get())  # 2\n\n# Common pitfall\nfunctions = []\nfor i in range(3):\n    functions.append(lambda x=i: x)  # Use default to capture\n\nprint([f() for f in functions])  # [0, 1, 2]\n```\n\n### Decorators Quick Reference\n\n```python\n# Simple decorator\ndef decorator(func):\n    def wrapper(*args, **kwargs):\n        print(\"Before\")\n        result = func(*args, **kwargs)\n        print(\"After\")\n        return result\n    return wrapper\n\n@decorator\ndef function():\n    print(\"Function\")\n\n# Decorator with arguments\ndef decorator_with_args(prefix):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            print(prefix)\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator\n\n@decorator_with_args(\"Hello: \")\ndef function():\n    print(\"Function\")\n\n# Using functools.wraps (IMPORTANT!)\nimport functools\n\ndef decorator(func):\n    @functools.wraps(func)  # Preserve metadata\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n    return wrapper\n\n# Stacking decorators (applied bottom to top)\n@decorator1\n@decorator2\n@decorator3\ndef function():\n    pass\n# Equivalent to: decorator1(decorator2(decorator3(function)))\n```\n\n### Common Decorators Pattern\n\n| Decorator | Purpose | Code |\n|-----------|---------|------|\n| Logging | Log function calls | `@functools.lru_cache` |\n| Timing | Measure execution time | `@timer` |\n| Validation | Check arguments | `@validate` |\n| Caching | Memoize results | `@functools.lru_cache(maxsize=128)` |\n| Retry | Retry on failure | `@retry(max_attempts=3)` |\n| Rate limiting | Limit call frequency | `@rate_limit(calls=10, period=60)` |\n\n### Generators Quick Reference\n\n```python\n# Generator function (uses yield)\ndef gen_numbers(n):\n    for i in range(n):\n        yield i\n\n# Using generator\ngen = gen_numbers(3)\nprint(next(gen))  # 0\nprint(next(gen))  # 1\nprint(next(gen))  # 2\n# next(gen)  # StopIteration\n\n# Iterating generator\nfor value in gen_numbers(3):\n    print(value)  # 0, 1, 2\n\n# Generator expression (like list comprehension)\ngen_expr = (x**2 for x in range(5))\nprint(list(gen_expr))  # [0, 1, 4, 9, 16]\n\n# Generator vs List\n# List: [x for x in range(1000000)]  - creates entire list in memory\n# Gen:  (x for x in range(1000000))  - generates on demand\n```\n\n### Mutable Default Arguments (DANGER)\n\n```python\n# WRONG - mutable default shared across calls\ndef add_item(item, items=[]):\n    items.append(item)\n    return items\n\nprint(add_item(1))  # [1]\nprint(add_item(2))  # [1, 2] - UNEXPECTED!\n\n# CORRECT - use None\ndef add_item(item, items=None):\n    if items is None:\n        items = []\n    items.append(item)\n    return items\n\nprint(add_item(1))  # [1]\nprint(add_item(2))  # [2]\n```\n\n### Lambda Functions Quick Reference\n\n```python\n# Basic lambda\nsquare = lambda x: x**2\nprint(square(5))  # 25\n\n# Lambda with multiple arguments\nadd = lambda x, y: x + y\nprint(add(3, 5))  # 8\n\n# Lambda with map\nvalues = [1, 2, 3, 4, 5]\nsquared = list(map(lambda x: x**2, values))\nprint(squared)  # [1, 4, 9, 16, 25]\n\n# Lambda with filter\nevens = list(filter(lambda x: x % 2 == 0, values))\nprint(evens)  # [2, 4]\n\n# Lambda with sorted\ntuples = [(2, 'b'), (1, 'a'), (3, 'c')]\nsorted_tuples = sorted(tuples, key=lambda x: x[1])\nprint(sorted_tuples)  # [(1, 'a'), (2, 'b'), (3, 'c')]\n```\n\n### When to Use What\n\n| Situation | Use | Avoid |\n|-----------|-----|-------|\n| Simple anonymous function | lambda | def |\n| Complex function | def | lambda |\n| Reusable calculation | def | lambda |\n| Temporary operation | lambda | def |\n| Debugging needed | def (easier to debug) | lambda |\n| Multiple statements | def | lambda |\n| Need docstring | def | lambda |\n| Single expression | lambda | def |\n\n### Decision: Generator vs List\n\n| Situation | Use Generator | Use List |\n|-----------|---------------|----------|\n| Large dataset | ✓ | ✗ |\n| Need all at once | ✗ | ✓ |\n| One-time iteration | ✓ | ✗ |\n| Multiple iterations | ✗ | ✓ |\n| Memory critical | ✓ | ✗ |\n| Speed critical | ✓ | ✗ |\n| Need indexing | ✗ | ✓ |\n| Infinite sequence | ✓ | ✗ |\n\n### Decision: Decorator vs Function\n\n| Situation | Use Decorator | Use Function |\n|-----------|---------------|---------------|\n| Wrap many functions | ✓ | ✗ |\n| Modify single function | ✓ | ✗ |\n| Reuse behavior | ✓ | ✗ |\n| Log/timing/retry | ✓ | ✗ |\n| One-time use | ✗ | ✓ |\n| Cleaner syntax needed | ✓ | ✗ |\n| Framework integration | ✓ | ✗ |\n\n### Time Complexity Reference\n\n| Complexity | Name | Example |\n|------------|------|----------|\n| O(1) | Constant | Array access by index |\n| O(log n) | Logarithmic | Binary search |\n| O(n) | Linear | Simple loop |\n| O(n log n) | Linearithmic | Merge sort, heap sort |\n| O(n²) | Quadratic | Nested loops |\n| O(n³) | Cubic | Triple nested loops |\n| O(2ⁿ) | Exponential | Recursive fibonacci |\n| O(n!) | Factorial | Permutations |\n\n### Common Optimization Patterns\n\n```python\n# 1. Use generators instead of lists\nresult = sum(x**2 for x in range(1000000))  # Efficient\n\n# 2. Early return/exit\ndef find(items, target):\n    for item in items:\n        if item == target:\n            return True  # Exit early\n    return False\n\n# 3. Memoization\nfrom functools import lru_cache\n\n@lru_cache(maxsize=128)\ndef expensive_function(n):\n    return fib(n - 1) + fib(n - 2)\n\n# 4. Use built-in functions\ntotal = sum(items)  # Faster than manual loop\n\n# 5. Avoid function calls in loops\nstr_len = len  # Cache function reference\nfor item in items:\n    str_len(str(item))\n```\n\n### Recursion Quick Reference\n\n```python\n# Structure: base case + recursive case\ndef recursive_function(n):\n    if n == 0:  # BASE CASE - stops recursion\n        return 1\n    return n * recursive_function(n - 1)  # RECURSIVE CASE\n\n# Tail recursion (Python doesn't optimize)\ndef tail_recursive(n, acc=1):\n    if n <= 1:\n        return acc\n    return tail_recursive(n - 1, n * acc)\n\n# Memoization for efficiency\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\n# Check recursion limit\nimport sys\nprint(sys.getrecursionlimit())  # Usually 1000\n```\n\n### Function Introspection\n\n```python\ndef example(name: str, age: int = 30) -> str:\n    \"\"\"Example function.\"\"\"\n    return f\"{name} is {age}\"\n\n# Introspection\nprint(example.__name__)           # 'example'\nprint(example.__doc__)            # 'Example function.'\nprint(example.__annotations__)    # {'name': str, 'age': int, 'return': str}\nprint(example.__code__.co_varnames)  # ('name', 'age')\nprint(example.__code__.co_argcount)  # 2\nprint(example.__defaults__)       # (30,)\n\n# Inspect module (advanced)\nimport inspect\nprint(inspect.signature(example))  # (name: str, age: int = 30) -> str\nprint(inspect.getsource(example))  # Full source code\n```\n\n### Functional Programming Patterns\n\n```python\nfrom functools import reduce\nfrom typing import Callable, List, TypeVar\n\nT = TypeVar('T')\nU = TypeVar('U')\n\n# Map: apply function to each element\nmap_pattern = lambda f, items: list(map(f, items))\n\n# Filter: keep elements where function is True\nfilter_pattern = lambda f, items: list(filter(f, items))\n\n# Reduce: apply function cumulatively\nreduce_pattern = lambda f, items: reduce(f, items)\n\n# Compose: combine functions\ncompose = lambda f, g: lambda x: f(g(x))\n\n# Pipe: apply functions in sequence\ndef pipe(value, *functions):\n    result = value\n    for func in functions:\n        result = func(result)\n    return result\n\nresult = pipe(5, lambda x: x * 2, lambda x: x + 10)  # 20\n```\n\n### Debugging Functions\n\n```python\n# 1. Print debugging\ndef function(x):\n    print(f\"Input: {x}\")\n    result = x * 2\n    print(f\"Result: {result}\")\n    return result\n\n# 2. Using pdb\nimport pdb\n\ndef function(x):\n    pdb.set_trace()  # Debugger stops here\n    return x * 2\n\n# 3. Assertions\ndef function(x):\n    assert x > 0, \"x must be positive\"\n    return x * 2\n\n# 4. Profiling\nimport cProfile\ncProfile.run('function(5)')\n\n# 5. Timing\nimport time\nstart = time.time()\nfunction(5)\nprint(f\"Time: {time.time() - start:.4f}s\")\n```"
}
