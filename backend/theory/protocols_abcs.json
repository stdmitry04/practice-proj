{
  "beginner": "## Protocols & ABCs: Beginner Level\n\n### What Are Abstract Base Classes (ABCs)?\n\nAn **Abstract Base Class** defines a blueprint that other classes must follow. It's like a contract that says \"if you inherit from me, you MUST implement these methods.\"\n\n#### Why Use ABCs?\n\n1. **Enforce Interface**: Ensure subclasses implement required methods\n2. **Documentation**: Clear contract showing what methods are needed\n3. **Type Safety**: Catch missing implementations early\n4. **Polymorphism**: Treat different implementations uniformly\n\n```python\n# Without ABC - no enforcement\nclass Animal:\n    def make_sound(self):\n        pass  # Easy to forget to implement\n\nclass Dog(Animal):\n    pass  # Forgot make_sound - no error!\n\ndog = Dog()\ndog.make_sound()  # Does nothing\n\n# With ABC - enforces implementation\nfrom abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    @abstractmethod\n    def make_sound(self):\n        pass  # Must be implemented\n\nclass Dog(Animal):\n    pass  # TypeError: Can't instantiate without make_sound\n\n# This forces proper implementation:\nclass Dog(Animal):\n    def make_sound(self):\n        return \"Woof!\"\n\ndog = Dog()  # Now it works\nprint(dog.make_sound())  # \"Woof!\"\n```\n\n---\n\n### Creating Your First ABC\n\n#### Step 1: Import ABC and abstractmethod\n\n```python\nfrom abc import ABC, abstractmethod\n```\n\n#### Step 2: Create Abstract Class\n\n```python\nclass Shape(ABC):  # Inherit from ABC\n    @abstractmethod\n    def area(self):  # Mark as abstract\n        \"\"\"Calculate area - must be implemented\"\"\"\n        pass\n    \n    @abstractmethod\n    def perimeter(self):  # Another abstract method\n        \"\"\"Calculate perimeter - must be implemented\"\"\"\n        pass\n```\n\n#### Step 3: Create Concrete Implementation\n\n```python\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):  # Must implement\n        return self.width * self.height\n    \n    def perimeter(self):  # Must implement\n        return 2 * (self.width + self.height)\n\nrect = Rectangle(5, 3)\nprint(rect.area())       # 15\nprint(rect.perimeter())  # 16\n```\n\n---\n\n### The @abstractmethod Decorator\n\nThis decorator marks methods that MUST be implemented by subclasses.\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Database(ABC):\n    @abstractmethod\n    def connect(self):\n        \"\"\"Connect to database\"\"\"\n        pass\n    \n    @abstractmethod\n    def disconnect(self):\n        \"\"\"Disconnect from database\"\"\"\n        pass\n    \n    @abstractmethod\n    def query(self, sql):\n        \"\"\"Execute SQL query\"\"\"\n        pass\n\n# Cannot instantiate abstract class\n# db = Database()  # TypeError\n\n# Must implement all abstract methods\nclass PostgreSQL(Database):\n    def connect(self):\n        print(\"Connecting to PostgreSQL\")\n    \n    def disconnect(self):\n        print(\"Disconnecting from PostgreSQL\")\n    \n    def query(self, sql):\n        print(f\"Executing: {sql}\")\n        return []\n\ndb = PostgreSQL()\ndb.connect()\ndb.query(\"SELECT * FROM users\")\ndb.disconnect()\n```\n\n---\n\n### Duck Typing: The Python Philosophy\n\n**Duck Typing**: \"If it walks like a duck and quacks like a duck, it's a duck.\"\n\nPython doesn't require explicit type declarations. If an object has the right methods, it works.\n\n```python\n# Without ABCs - duck typing\ndef process_shape(shape):\n    # Don't check type, just use it\n    print(f\"Area: {shape.area()}\")\n\nclass Circle:\n    def __init__(self, radius):\n        self.radius = radius\n    \n    def area(self):\n        return 3.14 * self.radius ** 2\n\nclass Square:\n    def __init__(self, side):\n        self.side = side\n    \n    def area(self):\n        return self.side ** 2\n\nprocess_shape(Circle(5))   # Works\nprocess_shape(Square(4))   # Works\n# No inheritance needed!\n```\n\n---\n\n### When to Use ABCs\n\n#### Use ABCs When:\n\n```python\n# 1. Defining a clear interface\nclass PaymentProcessor(ABC):\n    @abstractmethod\n    def process_payment(self, amount):\n        pass\n\n# 2. Multiple implementations of same interface\nclass CreditCardProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        print(f\"Processing ${amount} via credit card\")\n\nclass PayPalProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        print(f\"Processing ${amount} via PayPal\")\n\n# 3. Framework design\nclass Plugin(ABC):\n    @abstractmethod\n    def initialize(self):\n        pass\n    \n    @abstractmethod\n    def execute(self):\n        pass\n```\n\n#### Don't Use ABCs When:\n\n```python\n# 1. Simple functions suffice\ndef calculate_area(width, height):\n    return width * height\n\n# 2. Duck typing is enough\ndef print_items(container):\n    for item in container:  # Works with any iterable\n        print(item)\n\n# 3. Single implementation\nclass Logger:  # No need for ABC if only one implementation\n    def log(self, message):\n        print(message)\n```\n\n---\n\n### Common ABC Examples\n\n#### File Handler ABC\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass FileHandler(ABC):\n    @abstractmethod\n    def read(self, filename):\n        pass\n    \n    @abstractmethod\n    def write(self, filename, data):\n        pass\n\nclass TextFileHandler(FileHandler):\n    def read(self, filename):\n        with open(filename, 'r') as f:\n            return f.read()\n    \n    def write(self, filename, data):\n        with open(filename, 'w') as f:\n            f.write(data)\n\nclass JSONFileHandler(FileHandler):\n    def read(self, filename):\n        import json\n        with open(filename, 'r') as f:\n            return json.load(f)\n    \n    def write(self, filename, data):\n        import json\n        with open(filename, 'w') as f:\n            json.dump(data, f)\n```\n\n#### Vehicle Fleet ABC\n\n```python\nclass Vehicle(ABC):\n    @abstractmethod\n    def start_engine(self):\n        pass\n    \n    @abstractmethod\n    def stop_engine(self):\n        pass\n    \n    @abstractmethod\n    def fuel_type(self):\n        pass\n\nclass GasCar(Vehicle):\n    def start_engine(self):\n        print(\"Gas engine starting...\")\n    \n    def stop_engine(self):\n        print(\"Gas engine stopping...\")\n    \n    def fuel_type(self):\n        return \"Gasoline\"\n\nclass ElectricCar(Vehicle):\n    def start_engine(self):\n        print(\"Electric motor starting...\")\n    \n    def stop_engine(self):\n        print(\"Electric motor stopping...\")\n    \n    def fuel_type(self):\n        return \"Electricity\"\n```\n\n---\n\n### Common Beginner Mistakes\n\n#### Mistake 1: Forgetting @abstractmethod\n\n```python\n# WRONG\nclass Base(ABC):\n    def required_method(self):  # Not abstract!\n        pass\n\nclass Child(Base):\n    pass  # Can create without implementing\n\n# CORRECT\nclass Base(ABC):\n    @abstractmethod\n    def required_method(self):  # Now abstract\n        pass\n\nclass Child(Base):\n    def required_method(self):  # Must implement\n        return \"implemented\"\n```\n\n#### Mistake 2: Trying to Instantiate ABC\n\n```python\nclass Animal(ABC):\n    @abstractmethod\n    def sound(self):\n        pass\n\n# WRONG\n# animal = Animal()  # TypeError\n\n# CORRECT\nclass Dog(Animal):\n    def sound(self):\n        return \"Woof\"\n\ndog = Dog()  # OK\n```\n\n#### Mistake 3: Forgetting to Inherit from ABC\n\n```python\n# WRONG - doesn't inherit from ABC\nclass Base:  # Not an ABC!\n    @abstractmethod\n    def method(self):\n        pass\n\nclass Child(Base):\n    pass  # No error - @abstractmethod ignored\n\n# CORRECT\nfrom abc import ABC, abstractmethod\n\nclass Base(ABC):  # Now it's an ABC\n    @abstractmethod\n    def method(self):\n        pass\n\nclass Child(Base):\n    def method(self):  # Must implement\n        return \"done\"\n```",
  "intermediate": "## Protocols & ABCs: Intermediate Level\n\n### Abstract Properties\n\nYou can make properties abstract too.\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @property\n    @abstractmethod\n    def area(self):\n        \"\"\"Area must be a property\"\"\"\n        pass\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self._radius = radius\n    \n    @property\n    def area(self):  # Implement as property\n        return 3.14 * self._radius ** 2\n\ncircle = Circle(5)\nprint(circle.area)  # 78.5 (property, not method call)\n```\n\n---\n\n### Abstract Class Methods and Static Methods\n\n```python\nclass DataParser(ABC):\n    @classmethod\n    @abstractmethod\n    def from_file(cls, filename):\n        \"\"\"Load from file - must be implemented as classmethod\"\"\"\n        pass\n    \n    @staticmethod\n    @abstractmethod\n    def validate_format(data):\n        \"\"\"Validate data format - must be implemented as staticmethod\"\"\"\n        pass\n    \n    @abstractmethod\n    def parse(self, data):\n        \"\"\"Parse data - must be implemented as instance method\"\"\"\n        pass\n\nclass JSONParser(DataParser):\n    @classmethod\n    def from_file(cls, filename):\n        import json\n        with open(filename) as f:\n            return cls(json.load(f))\n    \n    @staticmethod\n    def validate_format(data):\n        return isinstance(data, dict)\n    \n    def __init__(self, data):\n        self.data = data\n    \n    def parse(self, data):\n        return data\n```\n\n---\n\n### Introduction to Protocols (PEP 544)\n\n**Protocols** allow structural subtyping - an object is considered to match a protocol if it has the required methods, regardless of inheritance.\n\n```python\nfrom typing import Protocol\n\nclass Drawable(Protocol):\n    \"\"\"Any object with a draw() method is Drawable\"\"\"\n    def draw(self) -> str:\n        ...\n\n# No inheritance needed!\nclass Circle:\n    def draw(self) -> str:\n        return \"Drawing circle\"\n\nclass Square:\n    def draw(self) -> str:\n        return \"Drawing square\"\n\ndef render(shape: Drawable):\n    print(shape.draw())\n\nrender(Circle())  # Works - has draw()\nrender(Square())  # Works - has draw()\n# Type checker verifies at compile time\n```\n\n---\n\n### Protocols vs ABCs\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import Protocol\n\n# ABC: Explicit inheritance required\nclass Animal(ABC):\n    @abstractmethod\n    def make_sound(self) -> str:\n        pass\n\nclass Dog(Animal):  # Must explicitly inherit\n    def make_sound(self) -> str:\n        return \"Woof\"\n\n# Protocol: Structural (duck typing)\nclass SoundMaker(Protocol):\n    def make_sound(self) -> str:\n        ...\n\nclass Cat:  # No inheritance\n    def make_sound(self) -> str:\n        return \"Meow\"\n\ndef play_sound(maker: SoundMaker):\n    print(maker.make_sound())\n\nplay_sound(Cat())  # Works - has make_sound()\n```\n\n#### When to Use Which?\n\n| Use ABC When | Use Protocol When |\n|-------------|------------------|\n| You control the hierarchy | Working with external code |\n| You want runtime checks | You want static type checking |\n| You need shared implementation | You only care about structure |\n| Explicit contract needed | Duck typing is preferred |\n\n---\n\n### @runtime_checkable Protocols\n\nMake protocols checkable at runtime with isinstance().\n\n```python\nfrom typing import Protocol, runtime_checkable\n\n@runtime_checkable\nclass Closable(Protocol):\n    def close(self) -> None:\n        ...\n\nclass File:\n    def close(self) -> None:\n        print(\"Closing file\")\n\nclass Connection:\n    def close(self) -> None:\n        print(\"Closing connection\")\n\nf = File()\nprint(isinstance(f, Closable))  # True\n\nc = Connection()\nprint(isinstance(c, Closable))  # True\n```\n\n---\n\n### Built-in Protocols\n\nPython has many built-in protocols you already use.\n\n#### Iterator Protocol\n\n```python\nclass Countdown:\n    def __init__(self, start):\n        self.current = start\n    \n    def __iter__(self):\n        return self\n    \n    def __next__(self):\n        if self.current <= 0:\n            raise StopIteration\n        self.current -= 1\n        return self.current + 1\n\nfor num in Countdown(5):\n    print(num)  # 5, 4, 3, 2, 1\n```\n\n#### Sequence Protocol\n\n```python\nclass MyList:\n    def __init__(self, items):\n        self._items = items\n    \n    def __len__(self):\n        return len(self._items)\n    \n    def __getitem__(self, index):\n        return self._items[index]\n\nmy_list = MyList([1, 2, 3, 4, 5])\nprint(len(my_list))    # 5\nprint(my_list[2])      # 3\nfor item in my_list:   # Works!\n    print(item)\n```\n\n#### Context Manager Protocol\n\n```python\nclass ManagedFile:\n    def __init__(self, filename):\n        self.filename = filename\n    \n    def __enter__(self):\n        self.file = open(self.filename, 'w')\n        return self.file\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.file:\n            self.file.close()\n\nwith ManagedFile('test.txt') as f:\n    f.write('Hello, World!')\n# File automatically closed\n```\n\n---\n\n### Combining ABCs and Concrete Methods\n\nABCs can have both abstract and concrete methods.\n\n```python\nclass Document(ABC):\n    @abstractmethod\n    def save(self, filename):\n        \"\"\"Must be implemented\"\"\"\n        pass\n    \n    @abstractmethod\n    def load(self, filename):\n        \"\"\"Must be implemented\"\"\"\n        pass\n    \n    def backup(self, filename):  # Concrete method\n        \"\"\"Default implementation provided\"\"\"\n        backup_name = f\"{filename}.backup\"\n        self.save(backup_name)\n        print(f\"Backed up to {backup_name}\")\n\nclass TextDocument(Document):\n    def __init__(self):\n        self.content = \"\"\n    \n    def save(self, filename):\n        with open(filename, 'w') as f:\n            f.write(self.content)\n    \n    def load(self, filename):\n        with open(filename, 'r') as f:\n            self.content = f.read()\n    \n    # backup() is inherited!\n\ndoc = TextDocument()\ndoc.content = \"Hello\"\ndoc.save(\"doc.txt\")\ndoc.backup(\"doc.txt\")  # Uses inherited method\n```\n\n---\n\n### Creating a Plugin System with ABCs\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import List\n\nclass Plugin(ABC):\n    @abstractmethod\n    def name(self) -> str:\n        pass\n    \n    @abstractmethod\n    def execute(self, data: dict) -> dict:\n        pass\n    \n    @abstractmethod\n    def validate(self, data: dict) -> bool:\n        pass\n\nclass EmailPlugin(Plugin):\n    def name(self) -> str:\n        return \"EmailSender\"\n    \n    def execute(self, data: dict) -> dict:\n        print(f\"Sending email to {data['to']}\")\n        return {\"status\": \"sent\"}\n    \n    def validate(self, data: dict) -> bool:\n        return \"to\" in data and \"@\" in data[\"to\"]\n\nclass LoggerPlugin(Plugin):\n    def name(self) -> str:\n        return \"FileLogger\"\n    \n    def execute(self, data: dict) -> dict:\n        print(f\"Logging: {data['message']}\")\n        return {\"status\": \"logged\"}\n    \n    def validate(self, data: dict) -> bool:\n        return \"message\" in data\n\nclass PluginManager:\n    def __init__(self):\n        self.plugins: List[Plugin] = []\n    \n    def register(self, plugin: Plugin):\n        self.plugins.append(plugin)\n        print(f\"Registered plugin: {plugin.name()}\")\n    \n    def execute_all(self, data: dict):\n        for plugin in self.plugins:\n            if plugin.validate(data):\n                result = plugin.execute(data)\n                print(f\"{plugin.name()}: {result}\")\n\nmanager = PluginManager()\nmanager.register(EmailPlugin())\nmanager.register(LoggerPlugin())\n\nmanager.execute_all({\n    \"to\": \"user@example.com\",\n    \"message\": \"Test\"\n})\n```\n\n---\n\n### Structural vs Nominal Subtyping\n\n#### Nominal (ABCs)\n\nExplicit declaration of relationship.\n\n```python\nclass Animal(ABC):\n    @abstractmethod\n    def sound(self):\n        pass\n\nclass Dog(Animal):  # Explicitly declares it's an Animal\n    def sound(self):\n        return \"Woof\"\n\nprint(isinstance(Dog(), Animal))  # True - nominal relationship\n```\n\n#### Structural (Protocols)\n\nImplicit relationship based on structure.\n\n```python\nfrom typing import Protocol\n\nclass Barker(Protocol):\n    def bark(self) -> str:\n        ...\n\nclass Dog:  # Doesn't mention Barker\n    def bark(self) -> str:\n        return \"Woof\"\n\ndef make_bark(barker: Barker):\n    print(barker.bark())\n\nmake_bark(Dog())  # Works - structural match\n```",
  "advanced": "## Protocols & ABCs: Advanced Level\n\n### Multiple Inheritance with ABCs\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Readable(ABC):\n    @abstractmethod\n    def read(self) -> str:\n        pass\n\nclass Writable(ABC):\n    @abstractmethod\n    def write(self, data: str) -> None:\n        pass\n\nclass ReadWriteable(Readable, Writable):  # Multiple ABC inheritance\n    pass\n\nclass File(ReadWriteable):\n    def __init__(self, filename):\n        self.filename = filename\n        self.content = \"\"\n    \n    def read(self) -> str:\n        return self.content\n    \n    def write(self, data: str) -> None:\n        self.content = data\n\nf = File(\"test.txt\")\nf.write(\"Hello\")\nprint(f.read())  # \"Hello\"\n```\n\n---\n\n### Virtual Subclasses with ABCMeta\n\nRegister a class as a subclass without actual inheritance.\n\n```python\nfrom abc import ABC\n\nclass Drawable(ABC):\n    @abstractmethod\n    def draw(self):\n        pass\n\nclass Circle:\n    def draw(self):\n        return \"Circle\"\n\n# Register Circle as virtual subclass\nDrawable.register(Circle)\n\nprint(issubclass(Circle, Drawable))  # True\nprint(isinstance(Circle(), Drawable))  # True\n\n# But Circle doesn't actually inherit!\nprint(Circle.__bases__)  # (<class 'object'>,)\nprint(Circle.__mro__)    # [Circle, object] - no Drawable\n\n# Circle is not required to implement abstract methods\nclass BadCircle:\n    pass  # No draw() method\n\nDrawable.register(BadCircle)  # Still works!\nprint(isinstance(BadCircle(), Drawable))  # True\n# Runtime error if you try to use draw()\n```\n\n---\n\n### Generic Protocols with TypeVar\n\n```python\nfrom typing import Protocol, TypeVar, Generic\n\nT = TypeVar('T')\n\nclass Comparable(Protocol):\n    def __lt__(self, other: 'Comparable') -> bool:\n        ...\n\nclass Container(Protocol[T]):\n    def add(self, item: T) -> None:\n        ...\n    \n    def get(self) -> T:\n        ...\n\nclass IntContainer:\n    def __init__(self):\n        self.items = []\n    \n    def add(self, item: int) -> None:\n        self.items.append(item)\n    \n    def get(self) -> int:\n        return self.items[-1] if self.items else 0\n\ncontainer: Container[int] = IntContainer()\ncontainer.add(42)\nprint(container.get())  # 42\n```\n\n---\n\n### Protocol Variance\n\n```python\nfrom typing import Protocol, TypeVar\n\nT_co = TypeVar('T_co', covariant=True)  # Covariant\nT_contra = TypeVar('T_contra', contravariant=True)  # Contravariant\n\n# Covariant: can return subtype\nclass Producer(Protocol[T_co]):\n    def produce(self) -> T_co:\n        ...\n\n# Contravariant: can accept supertype\nclass Consumer(Protocol[T_contra]):\n    def consume(self, item: T_contra) -> None:\n        ...\n\nclass Animal:\n    pass\n\nclass Dog(Animal):\n    pass\n\nclass DogProducer:\n    def produce(self) -> Dog:\n        return Dog()\n\n# DogProducer is a Producer[Dog]\n# Also works as Producer[Animal] (covariant)\nproducer: Producer[Animal] = DogProducer()\n```\n\n---\n\n### Advanced ABC Patterns\n\n#### Template Method with ABC\n\n```python\nclass DataProcessor(ABC):\n    \"\"\"Template method pattern with ABC\"\"\"\n    \n    def process(self, data):\n        \"\"\"Template method - defines algorithm structure\"\"\"\n        validated = self.validate(data)\n        transformed = self.transform(validated)\n        result = self.save(transformed)\n        return result\n    \n    @abstractmethod\n    def validate(self, data):\n        \"\"\"Must implement validation\"\"\"\n        pass\n    \n    @abstractmethod\n    def transform(self, data):\n        \"\"\"Must implement transformation\"\"\"\n        pass\n    \n    @abstractmethod\n    def save(self, data):\n        \"\"\"Must implement saving\"\"\"\n        pass\n\nclass CSVProcessor(DataProcessor):\n    def validate(self, data):\n        # Validate CSV format\n        return data\n    \n    def transform(self, data):\n        # Transform to dict\n        return {\"csv\": data}\n    \n    def save(self, data):\n        # Save to database\n        print(f\"Saved: {data}\")\n        return True\n\nprocessor = CSVProcessor()\nprocessor.process(\"a,b,c\")  # Runs through all steps\n```\n\n---\n\n### ABC with __init_subclass__\n\n```python\nclass RegisteredPlugin(ABC):\n    _registry = {}\n    \n    def __init_subclass__(cls, plugin_name=None, **kwargs):\n        super().__init_subclass__(**kwargs)\n        if plugin_name:\n            cls._registry[plugin_name] = cls\n    \n    @abstractmethod\n    def execute(self):\n        pass\n    \n    @classmethod\n    def get_plugin(cls, name):\n        return cls._registry.get(name)\n\nclass EmailPlugin(RegisteredPlugin, plugin_name=\"email\"):\n    def execute(self):\n        return \"Sending email\"\n\nclass SMSPlugin(RegisteredPlugin, plugin_name=\"sms\"):\n    def execute(self):\n        return \"Sending SMS\"\n\nprint(RegisteredPlugin._registry)\n# {'email': <class 'EmailPlugin'>, 'sms': <class 'SMSPlugin'>}\n\nplugin = RegisteredPlugin.get_plugin(\"email\")\nif plugin:\n    instance = plugin()\n    print(instance.execute())  # \"Sending email\"\n```\n\n---\n\n### Protocol Composition\n\n```python\nfrom typing import Protocol\n\nclass Named(Protocol):\n    name: str\n\nclass Aged(Protocol):\n    age: int\n\nclass Person(Protocol):\n    name: str\n    age: int\n\n# Person is effectively Named + Aged\n\nclass Employee:\n    def __init__(self, name: str, age: int, employee_id: str):\n        self.name = name\n        self.age = age\n        self.employee_id = employee_id\n\ndef greet_person(p: Person):\n    print(f\"Hello {p.name}, age {p.age}\")\n\nemp = Employee(\"Alice\", 30, \"E123\")\ngreet_person(emp)  # Works - has name and age\n```\n\n---\n\n### Implementing Collection ABCs\n\n```python\nfrom collections.abc import MutableSequence\n\nclass MyList(MutableSequence):\n    def __init__(self):\n        self._items = []\n    \n    # Required abstract methods\n    def __getitem__(self, index):\n        return self._items[index]\n    \n    def __setitem__(self, index, value):\n        self._items[index] = value\n    \n    def __delitem__(self, index):\n        del self._items[index]\n    \n    def __len__(self):\n        return len(self._items)\n    \n    def insert(self, index, value):\n        self._items.insert(index, value)\n\n# Inherits: append, extend, pop, remove, etc.\nmy_list = MyList()\nmy_list.append(1)  # Inherited method!\nmy_list.extend([2, 3])\nprint(list(my_list))  # [1, 2, 3]\n```\n\n---\n\n### Performance Considerations\n\n#### ABC Overhead\n\n```python\nimport timeit\nfrom abc import ABC, abstractmethod\n\nclass RegularClass:\n    def method(self):\n        return 42\n\nclass AbstractBase(ABC):\n    @abstractmethod\n    def method(self):\n        pass\n\nclass ConcreteClass(AbstractBase):\n    def method(self):\n        return 42\n\nregular = RegularClass()\nabstract = ConcreteClass()\n\n# Benchmark method calls\nregular_time = timeit.timeit(lambda: regular.method(), number=1000000)\nabstract_time = timeit.timeit(lambda: abstract.method(), number=1000000)\n\nprint(f\"Regular: {regular_time:.4f}s\")\nprint(f\"ABC: {abstract_time:.4f}s\")\n# ABC has minimal overhead (<5%)\n```\n\n#### Protocol Overhead\n\n```python\nfrom typing import Protocol, runtime_checkable\nimport timeit\n\n@runtime_checkable\nclass HasMethod(Protocol):\n    def method(self) -> int:\n        ...\n\nclass MyClass:\n    def method(self) -> int:\n        return 42\n\nobj = MyClass()\n\n# isinstance with Protocol is slower than ABC\ntime_protocol = timeit.timeit(\n    lambda: isinstance(obj, HasMethod),\n    number=100000\n)\n\nfrom abc import ABC\nclass MyABC(ABC):\n    pass\n\nclass Concrete(MyABC):\n    pass\n\nobj2 = Concrete()\ntime_abc = timeit.timeit(\n    lambda: isinstance(obj2, MyABC),\n    number=100000\n)\n\nprint(f\"Protocol: {time_protocol:.4f}s\")\nprint(f\"ABC: {time_abc:.4f}s\")\n# ABC isinstance is faster\n```\n\n---\n\n### Real-World Example: ORM-like System\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Any, List\n\nclass Model(ABC):\n    \"\"\"Base model with ORM-like functionality\"\"\"\n    \n    def __init__(self, **kwargs):\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n    \n    @classmethod\n    @abstractmethod\n    def table_name(cls) -> str:\n        \"\"\"Return database table name\"\"\"\n        pass\n    \n    @abstractmethod\n    def validate(self) -> bool:\n        \"\"\"Validate model data\"\"\"\n        pass\n    \n    def save(self) -> bool:\n        \"\"\"Save to database (template method)\"\"\"\n        if not self.validate():\n            raise ValueError(\"Validation failed\")\n        \n        data = self.to_dict()\n        print(f\"INSERT INTO {self.table_name()} {data}\")\n        return True\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dictionary\"\"\"\n        return {k: v for k, v in self.__dict__.items() \n                if not k.startswith('_')}\n    \n    @classmethod\n    def find(cls, id: int) -> 'Model':\n        \"\"\"Find by ID (template method)\"\"\"\n        print(f\"SELECT * FROM {cls.table_name()} WHERE id={id}\")\n        # Return mock instance\n        return cls(id=id)\n\nclass User(Model):\n    @classmethod\n    def table_name(cls) -> str:\n        return \"users\"\n    \n    def validate(self) -> bool:\n        return hasattr(self, 'email') and '@' in self.email\n\nclass Product(Model):\n    @classmethod\n    def table_name(cls) -> str:\n        return \"products\"\n    \n    def validate(self) -> bool:\n        return hasattr(self, 'price') and self.price > 0\n\n# Usage\nuser = User(email=\"alice@example.com\", name=\"Alice\")\nuser.save()  # INSERT INTO users {'email': 'alice@example.com', 'name': 'Alice'}\n\nproduct = Product(name=\"Laptop\", price=999.99)\nproduct.save()  # INSERT INTO products {'name': 'Laptop', 'price': 999.99}\n\nfound_user = User.find(1)\n# SELECT * FROM users WHERE id=1\n```",
  "cheatsheet": "## Protocols & ABCs: Quick Reference\n\n### Basic ABC\n\n```python\nfrom abc import ABC, abstractmethod\n\n# Define ABC\nclass Interface(ABC):\n    @abstractmethod\n    def required_method(self):\n        pass\n\n# Implement\nclass Concrete(Interface):\n    def required_method(self):\n        return \"implemented\"\n\n# Cannot instantiate ABC\n# Interface()  # TypeError\n\n# Can instantiate concrete\nConcrete()  # OK\n```\n\n### Abstract Properties\n\n```python\nclass Shape(ABC):\n    @property\n    @abstractmethod\n    def area(self):\n        pass\n\nclass Circle(Shape):\n    def __init__(self, r):\n        self.r = r\n    \n    @property\n    def area(self):\n        return 3.14 * self.r ** 2\n```\n\n### Abstract Class/Static Methods\n\n```python\nclass Base(ABC):\n    @classmethod\n    @abstractmethod\n    def from_config(cls, config):\n        pass\n    \n    @staticmethod\n    @abstractmethod\n    def validate(data):\n        pass\n```\n\n### Protocol (Structural)\n\n```python\nfrom typing import Protocol\n\nclass Drawable(Protocol):\n    def draw(self) -> str:\n        ...\n\n# No inheritance needed\nclass Circle:\n    def draw(self) -> str:\n        return \"circle\"\n\ndef render(shape: Drawable):\n    print(shape.draw())\n\nrender(Circle())  # Works\n```\n\n### @runtime_checkable Protocol\n\n```python\nfrom typing import Protocol, runtime_checkable\n\n@runtime_checkable\nclass Closable(Protocol):\n    def close(self) -> None:\n        ...\n\nclass File:\n    def close(self) -> None:\n        print(\"Closing\")\n\nprint(isinstance(File(), Closable))  # True\n```\n\n### ABC vs Protocol Comparison\n\n| Feature | ABC | Protocol |\n|---------|-----|----------|\n| **Inheritance** | Required | Not required |\n| **Runtime check** | isinstance() | isinstance() with @runtime_checkable |\n| **Type checking** | Yes | Yes |\n| **Flexibility** | Lower | Higher |\n| **Use case** | Explicit contracts | Duck typing with types |\n\n### Built-in Protocols\n\n```python\n# Iterator\nclass Counter:\n    def __init__(self, max):\n        self.max = max\n        self.n = 0\n    \n    def __iter__(self):\n        return self\n    \n    def __next__(self):\n        if self.n >= self.max:\n            raise StopIteration\n        self.n += 1\n        return self.n\n\n# Sequence\nclass MyList:\n    def __len__(self): ...\n    def __getitem__(self, i): ...\n\n# Context Manager\nclass Resource:\n    def __enter__(self): ...\n    def __exit__(self, *args): ...\n\n# Callable\nclass Adder:\n    def __call__(self, x, y):\n        return x + y\n```\n\n### Virtual Subclass\n\n```python\nclass Base(ABC):\n    @abstractmethod\n    def method(self):\n        pass\n\nclass External:  # No inheritance\n    def method(self):\n        return \"ok\"\n\n# Register as virtual subclass\nBase.register(External)\n\nissubclass(External, Base)  # True\nisinstance(External(), Base)  # True\n```\n\n### Multiple ABC Inheritance\n\n```python\nclass Readable(ABC):\n    @abstractmethod\n    def read(self): pass\n\nclass Writable(ABC):\n    @abstractmethod\n    def write(self, data): pass\n\nclass File(Readable, Writable):\n    def read(self):\n        return \"data\"\n    \n    def write(self, data):\n        print(f\"Writing: {data}\")\n```\n\n### Concrete + Abstract Methods\n\n```python\nclass Base(ABC):\n    @abstractmethod\n    def required(self):\n        \"\"\"Must implement\"\"\"\n        pass\n    \n    def optional(self):\n        \"\"\"Provided implementation\"\"\"\n        return \"default\"\n\nclass Child(Base):\n    def required(self):\n        return \"implemented\"\n    # Inherits optional()\n```\n\n### Decision Tree\n\n```\nChoose between ABC and Protocol:\n\n1. Do you control the code?\n   ├─ YES → ABC (explicit contract)\n   └─ NO → Protocol (structural match)\n\n2. Need runtime enforcement?\n   ├─ YES → ABC\n   └─ NO → Protocol\n\n3. Need shared implementation?\n   ├─ YES → ABC\n   └─ NO → Protocol\n\n4. Working with existing code?\n   ├─ YES → Protocol\n   └─ NO → Either works\n```\n\n### Common Patterns\n\n```python\n# Pattern 1: Plugin System\nclass Plugin(ABC):\n    @abstractmethod\n    def execute(self, data):\n        pass\n\n# Pattern 2: Strategy\nclass Strategy(ABC):\n    @abstractmethod\n    def algorithm(self):\n        pass\n\n# Pattern 3: Template Method\nclass Template(ABC):\n    def process(self):\n        self.step1()\n        self.step2()\n    \n    @abstractmethod\n    def step1(self): pass\n    \n    @abstractmethod\n    def step2(self): pass\n```\n\n### Common Mistakes\n\n```python\n# ✗ Forgot @abstractmethod\nclass Bad(ABC):\n    def method(self):  # Not enforced!\n        pass\n\n# ✓ Correct\nclass Good(ABC):\n    @abstractmethod\n    def method(self):\n        pass\n\n# ✗ Forgot to inherit from ABC\nclass Bad:\n    @abstractmethod  # Ignored!\n    def method(self):\n        pass\n\n# ✓ Correct\nclass Good(ABC):\n    @abstractmethod\n    def method(self):\n        pass\n\n# ✗ Trying to instantiate ABC\n# abc = MyABC()  # TypeError\n\n# ✓ Instantiate concrete class\nconc = Concrete()  # OK\n```\n\n### Best Practices\n\n```python\n# ✓ Use ABCs for explicit contracts\nclass PaymentProcessor(ABC):\n    @abstractmethod\n    def process(self, amount):\n        pass\n\n# ✓ Use Protocols for duck typing\nfrom typing import Protocol\n\nclass Drawable(Protocol):\n    def draw(self) -> str: ...\n\n# ✓ Provide concrete helper methods\nclass Base(ABC):\n    @abstractmethod\n    def get_data(self):\n        pass\n    \n    def process(self):  # Helper\n        data = self.get_data()\n        return data.upper()\n\n# ✓ Document abstract methods\nclass API(ABC):\n    @abstractmethod\n    def fetch(self, url):\n        \"\"\"Fetch data from URL.\n        \n        Args:\n            url: The URL to fetch from\n        \n        Returns:\n            Response data\n        \"\"\"\n        pass\n```"
}
