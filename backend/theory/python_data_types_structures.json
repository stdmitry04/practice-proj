{
  "beginner": "## Data Types & Structures: Beginner Level\n\n### Understanding Mutability: The Foundation\n\nMutability is the core concept that distinguishes Python data structures. It determines whether you can change a value after creation.\n\n#### What is Mutability?\n\n**Mutable** means \"changeable\" - you can modify the contents without creating a new object.\n**Immutable** means \"unchangeable\" - once created, the value cannot be altered.\n\n```python\n# MUTABLE EXAMPLE: List\nmy_list = [1, 2, 3]\nmy_list[0] = 99  # Changes the original list\nprint(my_list)  # [99, 2, 3]\n\n# IMMUTABLE EXAMPLE: Tuple\nmy_tuple = (1, 2, 3)\nmy_tuple[0] = 99  # ERROR: TypeError: 'tuple' object does not support item assignment\n```\n\n#### Why Does Mutability Matter?\n\n1. **Predictability**: Immutable values won't change unexpectedly\n2. **Safety**: Can safely pass around immutable objects without worry\n3. **Performance**: Immutable objects can be cached and optimized\n4. **Hashability**: Only immutable objects can be dictionary keys or set members\n\n```python\n# Immutable objects can be dictionary keys\nconfig = {\n    (\"user\", \"name\"): \"Alice\",      # Tuple key works\n    (\"user\", \"age\"): 30              # Tuple key works\n}\n\n# This would FAIL:\n# broken_config = {[\"user\", \"name\"]: \"Alice\"}  # List can't be a key\n```\n\n---\n\n### Lists: The Flexible Collection\n\nLists are **mutable**, **ordered**, and **allow duplicates**. They're your go-to collection for most tasks.\n\n#### Creating Lists\n\n```python\n# Empty list\nempty_list = []\n\n# With initial values\nfruits = [\"apple\", \"banana\", \"orange\"]\n\n# Mixed types\nmixed = [1, \"hello\", 3.14, True]\n\n# Using list constructor\nnumbers = list(range(5))  # [0, 1, 2, 3, 4]\n```\n\n#### Accessing Elements\n\n```python\nfruits = [\"apple\", \"banana\", \"orange\", \"grape\"]\n\n# Positive indexing (left to right)\nprint(fruits[0])      # \"apple\"\nprint(fruits[2])      # \"orange\"\n\n# Negative indexing (right to left)\nprint(fruits[-1])     # \"grape\"\nprint(fruits[-2])     # \"orange\"\n```\n\n#### Slicing Lists\n\n```python\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# [start:stop:step]\nprint(numbers[2:5])       # [2, 3, 4] - elements at indices 2, 3, 4\nprint(numbers[:4])        # [0, 1, 2, 3] - from start to index 3\nprint(numbers[5:])        # [5, 6, 7, 8, 9] - from index 5 to end\nprint(numbers[::2])       # [0, 2, 4, 6, 8] - every 2nd element\nprint(numbers[::-1])      # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] - reversed\n```\n\n#### Common List Operations\n\n```python\nmy_list = [1, 2, 3]\n\n# Length\nprint(len(my_list))       # 3\n\n# Membership testing\nprint(2 in my_list)       # True\nprint(5 in my_list)       # False\n\n# Adding elements\nmy_list.append(4)         # [1, 2, 3, 4]\nmy_list.extend([5, 6])    # [1, 2, 3, 4, 5, 6]\nmy_list.insert(0, 0)      # [0, 1, 2, 3, 4, 5, 6]\n\n# Removing elements\nmy_list.remove(3)         # Removes first occurrence: [0, 1, 2, 4, 5, 6]\npopped = my_list.pop()    # Removes last: popped=6, list=[0, 1, 2, 4, 5]\npopped_first = my_list.pop(0)  # Removes first: [1, 2, 4, 5]\n\n# Finding elements\nprint(my_list.index(2))   # 1 (index of first 2)\nprint(my_list.count(2))   # 1 (how many 2s are there)\n```\n\n#### Sorting and Reversing\n\n```python\nnumbers = [3, 1, 4, 1, 5, 9, 2, 6]\n\n# Sorting (modifies in place)\nnumbers.sort()            # [1, 1, 2, 3, 4, 5, 6, 9]\n\n# Reversing\nnumbers.reverse()         # [9, 6, 5, 4, 3, 2, 1, 1]\n\n# Note: sorted() returns new list without modifying original\nnumbers = [3, 1, 4, 1, 5]\nsorted_nums = sorted(numbers)  # [1, 1, 3, 4, 5]\nprint(numbers)                 # [3, 1, 4, 1, 5] - unchanged\n```\n\n#### Iterating Through Lists\n\n```python\nfruits = [\"apple\", \"banana\", \"orange\"]\n\n# Simple loop\nfor fruit in fruits:\n    print(fruit)\n\n# With index\nfor index, fruit in enumerate(fruits):\n    print(f\"Index {index}: {fruit}\")\n\n# List comprehension (powerful!)\nsquares = [x**2 for x in range(5)]  # [0, 1, 4, 9, 16]\n```\n\n---\n\n### Tuples: The Immutable Alternative\n\nTuples are **immutable**, **ordered**, and **allow duplicates**. Use them when you need fixed collections.\n\n#### Creating Tuples\n\n```python\n# Using parentheses\ncoordinates = (10, 20)\nrgb_color = (255, 128, 0)\n\n# Single element tuple (comma is required!)\nsingle = (42,)            # Correct\nnot_tuple = (42)          # Wrong - this is just 42\n\n# Empty tuple\nempty = ()\n\n# Using tuple constructor\nt = tuple([1, 2, 3])      # (1, 2, 3)\n```\n\n#### Why Use Tuples?\n\n```python\n# 1. Return multiple values from functions\ndef get_user_info():\n    return (\"Alice\", 25, \"alice@example.com\")\n\nname, age, email = get_user_info()\n\n# 2. Dictionary keys (must be immutable)\nuser_profile = {\n    (\"Alice\", 2024): \"active\",\n    (\"Bob\", 2024): \"inactive\"\n}\n\n# 3. Set members (must be immutable)\nunique_coordinates = {(0, 0), (1, 1), (2, 2)}\n\n# 4. Function arguments that shouldn't be modified\npoint = (10, 20)\nprint(point)  # Guaranteed not to change\n```\n\n#### Tuple Unpacking\n\n```python\n# Simple unpacking\ncoords = (10, 20, 30)\nx, y, z = coords\n\n# Swapping variables (elegant!)\na, b = 1, 2\na, b = b, a  # Now a=2, b=1\n\n# Unpacking with *\nfirst, *middle, last = [1, 2, 3, 4, 5]\n# first=1, middle=[2, 3, 4], last=5\n\n# Ignoring values with _\nname, _, email = (\"Alice\", 25, \"alice@example.com\")\n# age is ignored\n```\n\n#### Tuple Methods (Limited)\n\n```python\nt = (1, 2, 3, 2, 4, 2)\n\n# Only two methods available!\nprint(t.index(2))         # 1 (first index of 2)\nprint(t.count(2))         # 3 (how many 2s)\n\n# That's it! No append, remove, sort, etc.\n```\n\n---\n\n### Dictionaries: Key-Value Pairs\n\nDictionaries are **mutable**, **unordered** (Python 3.7+ maintain insertion order), and map keys to values.\n\n#### Creating Dictionaries\n\n```python\n# Using braces\nperson = {\"name\": \"Alice\", \"age\": 25, \"city\": \"NYC\"}\n\n# Using dict constructor\nperson = dict(name=\"Alice\", age=25, city=\"NYC\")\n\n# From list of tuples\nperson = dict([(\"name\", \"Alice\"), (\"age\", 25)])\n\n# Empty dictionary\nempty_dict = {}\n```\n\n#### Accessing and Modifying\n\n```python\nperson = {\"name\": \"Alice\", \"age\": 25}\n\n# Get value\nprint(person[\"name\"])     # \"Alice\"\nprint(person[\"age\"])      # 25\n\n# Add or update\nperson[\"city\"] = \"NYC\"    # Add new key\nperson[\"age\"] = 26        # Update existing\n\n# Safe access (no KeyError)\nprint(person.get(\"email\"))     # None (key doesn't exist)\nprint(person.get(\"email\", \"N/A\"))  # \"N/A\" (default value)\n\n# Check if key exists\nif \"name\" in person:\n    print(person[\"name\"])\n```\n\n#### Common Dictionary Operations\n\n```python\nperson = {\"name\": \"Alice\", \"age\": 25, \"city\": \"NYC\"}\n\n# Get all keys, values, items\nprint(person.keys())       # dict_keys(['name', 'age', 'city'])\nprint(person.values())     # dict_values(['Alice', 25, 'NYC'])\nprint(person.items())      # dict_items([('name', 'Alice'), ('age', 25), ('city', 'NYC')])\n\n# Remove items\nremoved_value = person.pop(\"age\")  # Removes and returns value\nperson.popitem()           # Removes last added item\ndel person[\"city\"]         # Removes key (no return)\nperson.clear()             # Removes all items\n\n# Copy\nshallow_copy = person.copy()  # New dict, same contents\n\n# Update from another dict\nperson.update({\"age\": 26, \"email\": \"alice@example.com\"})\n```\n\n#### Iterating Through Dictionaries\n\n```python\nperson = {\"name\": \"Alice\", \"age\": 25}\n\n# Iterate over keys (default)\nfor key in person:\n    print(key)\n\n# Explicit iteration over values\nfor value in person.values():\n    print(value)\n\n# Iterate over key-value pairs\nfor key, value in person.items():\n    print(f\"{key}: {value}\")\n```\n\n---\n\n### Sets: Unique Collections\n\nSets are **mutable**, **unordered**, and contain only **unique elements**.\n\n#### Creating Sets\n\n```python\n# Using braces\ncolors = {\"red\", \"green\", \"blue\"}\n\n# From list (removes duplicates)\nunique_numbers = set([1, 2, 2, 3, 3, 3])\nprint(unique_numbers)  # {1, 2, 3}\n\n# Empty set (important!)\nempty_set = set()      # Correct\n# empty_set = {}       # Wrong - this is a dictionary!\n\n# String to set (individual characters)\nletters = set(\"hello\")\nprint(letters)         # {'h', 'e', 'l', 'o'}\n```\n\n#### Why Use Sets?\n\n```python\n# 1. Remove duplicates from list\nfruits = [\"apple\", \"banana\", \"apple\", \"orange\", \"banana\"]\nunique_fruits = list(set(fruits))\n\n# 2. Membership testing (very fast!)\nvisited = {\"NYC\", \"LA\", \"Chicago\"}\nif \"NYC\" in visited:\n    print(\"Already visited\")\n\n# 3. Set operations\nset_a = {1, 2, 3}\nset_b = {3, 4, 5}\n\n# Union: all elements from both\nprint(set_a | set_b)           # {1, 2, 3, 4, 5}\n\n# Intersection: elements in both\nprint(set_a & set_b)           # {3}\n\n# Difference: in first but not second\nprint(set_a - set_b)           # {1, 2}\n\n# Symmetric difference: in either but not both\nprint(set_a ^ set_b)           # {1, 2, 4, 5}\n```\n\n#### Set Methods\n\n```python\ncolors = {\"red\", \"green\"}\n\n# Add and remove\ncolors.add(\"blue\")             # {\"red\", \"green\", \"blue\"}\ncolors.remove(\"red\")           # {\"green\", \"blue\"} - ERROR if not found\ncolors.discard(\"yellow\")       # {\"green\", \"blue\"} - No error if not found\ncolors.pop()                   # Removes random element\n\n# Set operations\nset_a = {1, 2, 3}\nset_b = {3, 4, 5}\n\nset_a.update(set_b)            # set_a becomes {1, 2, 3, 4, 5}\nset_a.intersection_update(set_b)  # Keep only common elements\nset_a.difference_update(set_b)    # Remove elements found in set_b\n```\n\n---\n\n### Quick Comparison Table\n\n| Feature | List | Tuple | Dict | Set |\n|---------|------|-------|------|-----|\n| **Mutable** | Yes | No | Yes | Yes |\n| **Ordered** | Yes | Yes | Yes* | No |\n| **Allows Duplicates** | Yes | Yes | No (keys) | No |\n| **Indexable** | Yes | Yes | No | No |\n| **Can be Dict Key** | No | Yes | No | No |\n| **Can be Set Member** | No | Yes | No | No |\n| **Syntax** | `[1, 2, 3]` | `(1, 2, 3)` | `{\"a\": 1}` | `{1, 2, 3}` |\n\n*Python 3.7+\n\n---\n\n### Common Mistakes to Avoid\n\n#### Mistake 1: Confusing {} for Empty Set\n\n```python\n# WRONG\nempty = {}                 # This is a dict, not a set!\nprint(type(empty))         # <class 'dict'>\n\n# CORRECT\nempty_set = set()          # This is an empty set\nprint(type(empty_set))     # <class 'set'>\n```\n\n#### Mistake 2: Trying to Modify Immutable Objects\n\n```python\n# WRONG\nmy_tuple = (1, 2, 3)\nmy_tuple[0] = 99           # TypeError\n\n# Instead, create a new tuple\nmy_tuple = (99,) + my_tuple[1:]  # (99, 2, 3)\n```\n\n#### Mistake 3: Forgetting Dictionary Keys Must Be Unique\n\n```python\n# The second value wins\ndata = {\"key\": \"first\", \"key\": \"second\"}\nprint(data)                # {\"key\": \"second\"}\n```\n\n#### Mistake 4: Using list as Dictionary Key\n\n```python\n# WRONG - lists are mutable\ndata = {[1, 2]: \"value\"}   # TypeError\n\n# CORRECT - use tuple instead\ndata = {(1, 2): \"value\"}   # Works fine\n```",
  "intermediate": "## Data Types & Structures: Intermediate Level\n\n### Deep Dive: Mutability and References\n\n#### How Mutability Affects Variable Assignment\n\n```python\n# IMMUTABLE: Creating a copy\na = 5\nb = a\nb = 10\nprint(a, b)  # 5, 10 - a is unchanged\n\n# MUTABLE: Both reference the same object\nlist_a = [1, 2, 3]\nlist_b = list_a      # Both point to same list\nlist_b.append(4)\nprint(list_a)        # [1, 2, 3, 4] - list_a changed!\nprint(list_b)        # [1, 2, 3, 4]\nprint(list_a is list_b)  # True - same object\n```\n\n#### Shallow vs Deep Copy (for mutable objects)\n\n```python\n# SHALLOW COPY: Only copies the container\noriginal = [[1, 2], [3, 4]]\nshallow = original.copy()      # or list(original)\n\nshallow[0].append(99)          # Modifies nested list\nprint(original)                # [[1, 2, 99], [3, 4]] - Original affected!\nprint(shallow)                 # [[1, 2, 99], [3, 4]]\n\n# DEEP COPY: Copies everything recursively\nimport copy\noriginal = [[1, 2], [3, 4]]\ndeep = copy.deepcopy(original)\n\ndeep[0].append(99)\nprint(original)                # [[1, 2], [3, 4]] - Unchanged\nprint(deep)                    # [[1, 2, 99], [3, 4]]\n```\n\n---\n\n### Lists: Advanced Operations\n\n#### List Methods Explained\n\n```python\n# append() - add to end O(1)\nmy_list = [1, 2, 3]\nmy_list.append(4)          # [1, 2, 3, 4]\n\n# extend() - add multiple items O(k) where k is items added\nmy_list.extend([5, 6])     # [1, 2, 3, 4, 5, 6]\n\n# insert() - add at specific position O(n)\nmy_list.insert(0, 0)       # [0, 1, 2, 3, 4, 5, 6] - shifts everything\n\n# remove() - delete by value O(n)\nmy_list.remove(3)          # [0, 1, 2, 4, 5, 6]\n\n# pop() - remove by index (default last) O(1) for end, O(n) for beginning\nmy_list.pop()              # [0, 1, 2, 4, 5]\nmy_list.pop(0)             # [1, 2, 4, 5] - more expensive\n\n# clear() - remove all O(n)\nmy_list.clear()            # []\n\n# index() - find position of value O(n)\nmy_list = [10, 20, 30, 20]\nprint(my_list.index(20))   # 1 (first occurrence)\n\n# count() - count occurrences O(n)\nprint(my_list.count(20))   # 2\n\n# sort() - in-place sort O(n log n)\nmy_list.sort()             # [10, 20, 20, 30]\nmy_list.sort(reverse=True) # [30, 20, 20, 10]\n\n# reverse() - reverse order O(n)\nmy_list.reverse()          # Reverses in place\n```\n\n#### List Slicing Advanced\n\n```python\nnums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# Slice assignment (modify in place)\nnums[2:4] = [20, 30]       # [0, 1, 20, 30, 4, 5, 6, 7, 8, 9]\n\n# Insert via slicing\nnums[2:2] = [\"a\", \"b\"]     # [0, 1, \"a\", \"b\", 20, 30, 4, 5, 6, 7, 8, 9]\n\n# Delete via slicing\nnums[2:4] = []             # [0, 1, 20, 30, 4, 5, 6, 7, 8, 9]\n\n# Step slicing\nnums[::2] = [0, 2, 4, 6, 8]  # Replace every 2nd element\n```\n\n#### List Comprehensions with Conditions\n\n```python\n# Basic comprehension\nsquares = [x**2 for x in range(5)]         # [0, 1, 4, 9, 16]\n\n# With condition\nevens = [x for x in range(10) if x % 2 == 0]  # [0, 2, 4, 6, 8]\n\n# Multiple conditions\nresult = [x for x in range(10) if x > 2 if x < 8]  # [3, 4, 5, 6, 7]\n\n# With else (different from if alone)\nresult = [x if x % 2 == 0 else x**2 for x in range(5)]  # [0, 1, 4, 3, 16]\n\n# Nested comprehension\nmatrix = [[i*3 + j for j in range(3)] for i in range(3)]\n# [[0, 1, 2], [3, 4, 5], [6, 7, 8]]\n\n# Flattening nested lists\nflat = [x for row in matrix for x in row]  # [0, 1, 2, 3, 4, 5, 6, 7, 8]\n```\n\n---\n\n### Tuples: Practical Use Cases\n\n#### Named Tuples: Readable Alternative\n\n```python\nfrom collections import namedtuple\n\n# Create a named tuple\nPoint = namedtuple('Point', ['x', 'y'])\np = Point(10, 20)\n\nprint(p.x)         # 10 (access by name)\nprint(p.y)         # 20\nprint(p[0])        # 10 (still indexable)\nprint(p)           # Point(x=10, y=20) - readable output\n\n# Immutable but convenient\nCoordinate = namedtuple('Coordinate', ['lat', 'lon'])\ncities = [\n    Coordinate(40.7128, -74.0060),  # NYC\n    Coordinate(34.0522, -118.2437),  # LA\n]\n\nfor city in cities:\n    print(f\"Latitude: {city.lat}, Longitude: {city.lon}\")\n```\n\n#### Tuple Unpacking in Functions\n\n```python\ndef process_coordinates(point):\n    x, y = point  # Automatic unpacking\n    return x + y\n\nresult = process_coordinates((5, 10))  # 15\n\n# Multiple return values (returns tuple)\ndef get_stats(numbers):\n    return min(numbers), max(numbers), sum(numbers) / len(numbers)\n\nmin_val, max_val, avg = get_stats([1, 2, 3, 4, 5])\nprint(f\"Min: {min_val}, Max: {max_val}, Avg: {avg}\")\n```\n\n---\n\n### Dictionaries: Advanced Techniques\n\n#### Dictionary Methods Beyond Basics\n\n```python\nperson = {\"name\": \"Alice\", \"age\": 25}\n\n# setdefault() - get value or set default if missing\nprint(person.setdefault(\"age\", 30))      # 25 (already exists)\nprint(person.setdefault(\"city\", \"NYC\"))  # \"NYC\" (created and added)\nprint(person)  # {\"name\": \"Alice\", \"age\": 25, \"city\": \"NYC\"}\n\n# pop() with default\nprint(person.pop(\"city\", \"Unknown\"))     # \"NYC\"\nprint(person.pop(\"country\", \"Unknown\")) # \"Unknown\" (not found)\n\n# popitem() - remove and return last inserted pair\nitem = person.popitem()                  # (\"age\", 25) or similar\n\n# update() - merge another dict\nperson.update({\"age\": 26, \"email\": \"alice@example.com\"})\nprint(person)  # Merged\n```\n\n#### Dictionary Comprehensions\n\n```python\n# Basic comprehension\nsquares = {x: x**2 for x in range(5)}  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}\n\n# With condition\nevens = {x: x**2 for x in range(10) if x % 2 == 0}\n# {0: 0, 2: 4, 4: 16, 6: 36, 8: 64}\n\n# From list of tuples\npairs = [(\"a\", 1), (\"b\", 2), (\"c\", 3)]\ndict_from_pairs = {k: v for k, v in pairs}\n# {\"a\": 1, \"b\": 2, \"c\": 3}\n\n# Swapping keys and values\noriginal = {\"a\": 1, \"b\": 2}\nswapped = {v: k for k, v in original.items()}\n# {1: \"a\", 2: \"b\"}\n```\n\n#### Nested Dictionaries\n\n```python\n# Representing hierarchical data\ncompany = {\n    \"engineering\": {\n        \"employees\": 50,\n        \"manager\": \"Bob\"\n    },\n    \"sales\": {\n        \"employees\": 30,\n        \"manager\": \"Carol\"\n    }\n}\n\nprint(company[\"engineering\"][\"manager\"])  # \"Bob\"\n\n# Safe navigation with nested dicts\nif \"engineering\" in company and \"manager\" in company[\"engineering\"]:\n    print(company[\"engineering\"][\"manager\"])\n\n# Better: use get() chaining\nmanager = company.get(\"engineering\", {}).get(\"manager\", \"Unknown\")\n```\n\n#### from collections import defaultdict and Counter\n\n```python\nfrom collections import defaultdict, Counter\n\n# defaultdict - provides default value for missing keys\nword_count = defaultdict(int)\nfor word in \"apple banana apple cherry apple banana\".split():\n    word_count[word] += 1\nprint(word_count)  # defaultdict(<class 'int'>, {'apple': 3, 'banana': 2, 'cherry': 1})\n\n# Counter - specialized dict for counting\nfruits = [\"apple\", \"banana\", \"apple\", \"cherry\", \"apple\", \"banana\"]\nfruit_count = Counter(fruits)\nprint(fruit_count)           # Counter({'apple': 3, 'banana': 2, 'cherry': 1})\nprint(fruit_count[\"apple\"])  # 3\nprint(fruit_count.most_common(2))  # [('apple', 3), ('banana', 2)]\n```\n\n---\n\n### Sets: Advanced Operations\n\n#### Set Operations\n\n```python\nset_a = {1, 2, 3, 4}\nset_b = {3, 4, 5, 6}\n\n# Union (|) - all elements from both\nprint(set_a | set_b)           # {1, 2, 3, 4, 5, 6}\nprint(set_a.union(set_b))      # Same\n\n# Intersection (&) - common elements\nprint(set_a & set_b)           # {3, 4}\nprint(set_a.intersection(set_b))  # Same\n\n# Difference (-) - in first but not second\nprint(set_a - set_b)           # {1, 2}\nprint(set_a.difference(set_b)) # Same\n\n# Symmetric difference (^) - in either but not both\nprint(set_a ^ set_b)           # {1, 2, 5, 6}\nprint(set_a.symmetric_difference(set_b))  # Same\n\n# Subset and superset\nprint({1, 2}.issubset(set_a))      # True\nprint(set_a.issuperset({1, 2}))    # True\nprint({1, 2}.isdisjoint(set_b))    # True (no common elements)\n```\n\n#### Set Use Case: Removing Duplicates While Preserving Order\n\n```python\n# Problem: Remove duplicates from list but keep order\ndata = [1, 2, 3, 2, 4, 1, 5]\n\n# Using set loses order\nprint(list(set(data)))  # [1, 2, 3, 4, 5] - order not guaranteed\n\n# Better approach: use dict\nseen = {}\nfor item in data:\n    if item not in seen:\n        seen[item] = True\nprint(list(seen.keys()))  # [1, 2, 3, 4, 5] - order preserved in Python 3.7+\n\n# Or more concise using dict.fromkeys()\nprint(list(dict.fromkeys(data)))  # [1, 2, 3, 4, 5]\n```\n\n---\n\n### Collections Module\n\n#### deque: Double-Ended Queue\n\n```python\nfrom collections import deque\n\n# More efficient for popleft and appendleft\nq = deque([1, 2, 3, 4])\n\nq.append(5)            # Add to right: [1, 2, 3, 4, 5]\nq.appendleft(0)        # Add to left: [0, 1, 2, 3, 4, 5]\nq.pop()                # Remove from right: 5\nq.popleft()            # Remove from left: 0\n\nprint(q)               # deque([1, 2, 3, 4])\n\n# Rotating\nq.rotate(1)            # Rotate right: deque([4, 1, 2, 3])\nq.rotate(-1)           # Rotate left: deque([1, 2, 3, 4])\n```\n\n#### OrderedDict vs Regular Dict\n\n```python\nfrom collections import OrderedDict\n\n# Python 3.7+: Regular dict maintains insertion order\nregular_dict = {\"z\": 1, \"a\": 2, \"m\": 3}\nprint(regular_dict)  # Order preserved: {'z': 1, 'a': 2, 'm': 3}\n\n# OrderedDict is still useful for equality comparison\nod1 = OrderedDict([(\"a\", 1), (\"b\", 2)])\nod2 = OrderedDict([(\"b\", 2), (\"a\", 1)])\nprint(od1 == od2)  # False (different order matters)\n\n# Regular dicts: order doesn't matter for equality\nd1 = {\"a\": 1, \"b\": 2}\nd2 = {\"b\": 2, \"a\": 1}\nprint(d1 == d2)  # True\n```\n\n---\n\n### Performance: Big-O Analysis\n\n#### Time Complexity Comparison\n\n| Operation | List | Tuple | Dict | Set |\n|-----------|------|-------|------|-----|\n| **Access by index** | O(1) | O(1) | N/A | N/A |\n| **Search** | O(n) | O(n) | O(1) avg | O(1) avg |\n| **Insert** | O(n) | N/A | O(1) avg | O(1) avg |\n| **Delete** | O(n) | N/A | O(1) avg | O(1) avg |\n| **Append** | O(1) | N/A | N/A | O(1) avg |\n| **Contains check** | O(n) | O(n) | O(1) avg | O(1) avg |\n| **Sort** | O(n log n) | N/A | N/A | N/A |\n| **Copy** | O(n) | O(n) | O(n) | O(n) |\n\n#### Space Complexity\n\n```python\nimport sys\n\n# Compare memory usage\nlist_data = list(range(1000))\ndict_data = {i: i for i in range(1000)}\nset_data = set(range(1000))\n\nprint(f\"List: {sys.getsizeof(list_data)} bytes\")\nprint(f\"Dict: {sys.getsizeof(dict_data)} bytes\")\nprint(f\"Set: {sys.getsizeof(set_data)} bytes\")\n\n# Dictionaries and sets use more memory due to hashing overhead\n```\n\n#### Practical Performance Example\n\n```python\nimport time\n\n# Searching in list vs set\ndata_list = list(range(100000))\ndata_set = set(data_list)\n\n# List search O(n)\nstart = time.time()\nfound = 99999 in data_list\nlist_time = time.time() - start\n\n# Set search O(1) average\nstart = time.time()\nfound = 99999 in data_set\nset_time = time.time() - start\n\nprint(f\"List search: {list_time:.6f}s\")\nprint(f\"Set search: {set_time:.6f}s\")\nprint(f\"Set is ~{list_time/set_time:.0f}x faster\")\n```\n\n---\n\n### When to Use What: Decision Framework\n\n#### Flowchart-Style Decision Tree\n\n```\n1. Do you need key-value pairs?\n   YES → Use Dictionary\n   NO → Continue\n\n2. Do you need unique elements only?\n   YES → Use Set\n   NO → Continue\n\n3. Do you need the collection to be immutable?\n   YES → Use Tuple\n   NO → Use List\n```\n\n#### Detailed Comparison\n\n```python\n# USE LIST when:\n# - You have an ordered collection\n# - You need to modify it frequently (append, remove, etc.)\n# - You access items by position\nscores = [85, 92, 78, 95]\nscores.append(88)  # Add new score\n\n# USE TUPLE when:\n# - You need immutability (won't change)\n# - You're using it as a dictionary key\n# - You're unpacking values\ncoord = (10, 20)\nposition = {coord: \"origin\"}  # Works because tuple is immutable\n\n# USE DICT when:\n# - You need to map keys to values\n# - You need fast lookups by key\n# - You need labeled data\nuser = {\"name\": \"Alice\", \"age\": 25, \"email\": \"alice@example.com\"}\n\n# USE SET when:\n# - You need uniqueness\n# - You need set operations (union, intersection)\n# - You need fast membership testing\nvisited_countries = {\"USA\", \"Canada\", \"Mexico\"}\nif \"USA\" in visited_countries:  # Fast O(1)\n    print(\"Already visited\")\n```\n\n---\n\n### Common Intermediate Mistakes\n\n#### Mistake 1: Shallow Copy Issues\n\n```python\n# WRONG\noriginal = [[1, 2], [3, 4]]\ncopy_of_original = original.copy()  # Shallow copy!\n\ncopy_of_original[0][0] = 99\nprint(original)  # [[99, 2], [3, 4]] - Original modified!\n\n# CORRECT\nimport copy\ncopy_of_original = copy.deepcopy(original)\ncopy_of_original[0][0] = 99\nprint(original)  # [[1, 2], [3, 4]] - Unchanged\n```\n\n#### Mistake 2: Modifying While Iterating\n\n```python\n# WRONG\nmy_list = [1, 2, 3, 4, 5]\nfor item in my_list:\n    if item % 2 == 0:\n        my_list.remove(item)  # Skips items!\nprint(my_list)  # [1, 3, 5] - Lost elements\n\n# CORRECT\nmy_list = [1, 2, 3, 4, 5]\nmy_list = [x for x in my_list if x % 2 != 0]\nprint(my_list)  # [1, 3, 5] - All odd numbers\n```\n\n#### Mistake 3: Using Mutable Default Arguments\n\n```python\n# WRONG\ndef add_to_list(item, items=[]):  # Mutable default!\n    items.append(item)\n    return items\n\nlist1 = add_to_list(1)  # [1]\nlist2 = add_to_list(2)  # [1, 2] - Same list!\nprint(list1)  # [1, 2] - Unexpected!\n\n# CORRECT\ndef add_to_list(item, items=None):\n    if items is None:\n        items = []\n    items.append(item)\n    return items\n\nlist1 = add_to_list(1)  # [1]\nlist2 = add_to_list(2)  # [2]\nprint(list1)  # [1] - Correct\n```",
  "advanced": "## Data Types & Structures: Advanced Level\n\n### Understanding Hashing: The Magic Behind Dicts and Sets\n\n#### What is a Hash Function?\n\nA hash function converts an object into a fixed-size integer (hash code). This enables:\n- Fast lookups in dictionaries\n- Fast membership testing in sets\n- Dictionary key verification\n\n```python\n# All immutable objects are hashable\nprint(hash(\"hello\"))           # 2652529500128\nprint(hash((1, 2, 3)))         # 529344067295497451\nprint(hash(42))                # 42\n\n# Mutable objects are NOT hashable\nprint(hash([1, 2, 3]))         # TypeError: unhashable type: 'list'\nprint(hash({\"a\": 1}))          # TypeError: unhashable type: 'dict'\n\n# Same object always produces same hash (in same session)\nprint(hash(\"hello\"))           # Consistent\nprint(hash(\"hello\"))           # Same value\n```\n\n#### How Dictionary Lookup Works\n\n```python\n# Simplified internal process:\n\ndata = {\"key1\": \"value1\", \"key2\": \"value2\"}\n\n# When you do: data[\"key1\"]\n# Python does:\n# 1. hash(\"key1\") → some_integer\n# 2. Find bucket at index: some_integer % num_buckets\n# 3. Check if key exists in bucket (handling collisions)\n# 4. Return associated value\n\n# This is why lookup is O(1) average case!\n\n# Hash collisions are handled internally:\ndata = {}\ndata[\"cat\"] = 1    # hash(\"cat\") % buckets → index 5\ndata[\"tac\"] = 2    # hash(\"tac\") % buckets → index 5 (same bucket!)\n# Python handles this by storing both key-value pairs in the bucket\n```\n\n#### Creating Hashable Custom Classes\n\n```python\n# Immutable custom class\nclass Point:\n    def __init__(self, x, y):\n        self._x = x\n        self._y = y\n    \n    def __eq__(self, other):\n        return self._x == other._x and self._y == other._y\n    \n    def __hash__(self):\n        # Custom hash based on coordinates\n        return hash((self._x, self._y))\n    \n    def __repr__(self):\n        return f\"Point({self._x}, {self._y})\"\n\np1 = Point(10, 20)\np2 = Point(10, 20)\n\nprint(p1 == p2)              # True (equal points)\nprint(hash(p1) == hash(p2))  # True (same hash)\n\n# Can use as dict key\nlocations = {p1: \"origin\", Point(5, 5): \"other\"}\nprint(locations[p2])         # \"origin\" (p2 is equivalent to p1)\n\n# Can use in sets\npoints = {Point(0, 0), Point(1, 1), p1}\nprint(len(points))           # 2 (p1 and Point(10, 20) are same)\n```\n\n---\n\n### Memory Optimization and Internals\n\n#### Understanding Object Size\n\n```python\nimport sys\n\n# Empty structures\nprint(f\"Empty list: {sys.getsizeof([])} bytes\")\nprint(f\"Empty tuple: {sys.getsizeof(())} bytes\")\nprint(f\"Empty dict: {sys.getsizeof({})} bytes\")\nprint(f\"Empty set: {sys.getsizeof(set())} bytes\")\n\n# Lists grow with some overhead\nfor size in [1, 10, 100, 1000]:\n    lst = list(range(size))\n    print(f\"List of {size:4d} items: {sys.getsizeof(lst):5d} bytes\")\n\n# Dicts have larger overhead\nfor size in [1, 10, 100, 1000]:\n    d = {i: i for i in range(size)}\n    print(f\"Dict with {size:4d} items: {sys.getsizeof(d):5d} bytes\")\n```\n\n#### Memory Layout: Lists vs Tuples\n\n```python\nimport sys\n\n# Lists allocate extra space for future growth\nlist1 = [1, 2, 3]\nprint(f\"List [1,2,3] allocated: {sys.getsizeof(list1)} bytes\")\n\nlist1.append(4)  # Reuses allocated space, no reallocation\nprint(f\"After append: {sys.getsizeof(list1)} bytes (same)\")\n\n# Tuples don't need extra space (immutable)\ntuple1 = (1, 2, 3)\nprint(f\"Tuple (1,2,3) size: {sys.getsizeof(tuple1)} bytes\")\n\n# For fixed collections, tuples are more memory-efficient\n```\n\n#### Dictionary Load Factor and Resizing\n\n```python\n# Dictionaries resize when load factor (items/buckets) gets too high\n# Python uses approximately 2/3 load factor\n\ndata = {}\nprint(f\"Empty dict size: {data.__sizeof__()} bytes\")\n\n# Adding items triggers resizing at certain thresholds\nfor i in range(1, 11):\n    data[i] = i\n    print(f\"After {i} items: {data.__sizeof__():5d} bytes\")\n\n# Notice jumps when resizing occurs\n```\n\n---\n\n### Performance Optimization Techniques\n\n#### Choosing the Right Data Structure\n\n```python\n# PROBLEM: Check if 1 million random items exist in a collection\n\nimport time\nimport random\n\ndata_list = list(range(1000000))\ndata_set = set(range(1000000))\n\n# Test searches\ntest_items = [random.randint(0, 999999) for _ in range(10000)]\n\n# List search: O(n)\nstart = time.time()\ncount = sum(1 for item in test_items if item in data_list)\nlist_time = time.time() - start\n\n# Set search: O(1)\nstart = time.time()\ncount = sum(1 for item in test_items if item in data_set)\nset_time = time.time() - start\n\nprint(f\"List: {list_time:.4f}s\")\nprint(f\"Set: {set_time:.4f}s\")\nprint(f\"Set is {list_time/set_time:.0f}x faster!\")\n```\n\n#### Optimizing Dictionary Operations\n\n```python\n# Use setdefault() to avoid multiple lookups\nword_count = {}\n\n# INEFFICIENT: Two lookups\nif word not in word_count:\n    word_count[word] = 0\nword_count[word] += 1\n\n# EFFICIENT: One lookup\nword_count.setdefault(word, 0)\nword_count[word] += 1\n\n# BETTER: Use defaultdict\nfrom collections import defaultdict\nword_count = defaultdict(int)\nword_count[word] += 1  # No need to check or set default\n```\n\n#### List vs Deque for Queue Operations\n\n```python\nimport time\nfrom collections import deque\n\n# Remove from beginning is expensive for lists\ndata_list = list(range(10000))\nstart = time.time()\nfor _ in range(100):\n    data_list.pop(0)  # O(n) operation!\nlist_time = time.time() - start\n\n# But efficient for deques\ndata_deque = deque(range(10000))\nstart = time.time()\nfor _ in range(100):\n    data_deque.popleft()  # O(1) operation\ndeque_time = time.time() - start\n\nprint(f\"List.pop(0): {list_time:.4f}s\")\nprint(f\"Deque.popleft(): {deque_time:.4f}s\")\nprint(f\"Deque is {list_time/deque_time:.0f}x faster for this use case\")\n```\n\n---\n\n### Advanced Type Hints for Collections\n\n#### Generic Type Hints\n\n```python\nfrom typing import List, Dict, Set, Tuple, Optional\n\n# Basic generic types\ndef process_numbers(nums: List[int]) -> int:\n    return sum(nums)\n\ndef create_mapping(keys: List[str], values: List[int]) -> Dict[str, int]:\n    return dict(zip(keys, values))\n\n# Tuple with fixed types\ndef get_user() -> Tuple[str, int, str]:\n    return (\"Alice\", 25, \"alice@example.com\")\n\n# Set of strings\ndef get_unique_names(names: List[str]) -> Set[str]:\n    return set(names)\n\n# Optional (nullable)\ndef find_user(user_id: int) -> Optional[Dict[str, str]]:\n    users = {1: {\"name\": \"Alice\"}, 2: {\"name\": \"Bob\"}}\n    return users.get(user_id)\n```\n\n#### Advanced Generic Types\n\n```python\nfrom typing import List, Dict, Union, Any, Callable\n\n# Union types\ndef process_value(val: Union[int, str]) -> None:\n    if isinstance(val, int):\n        print(f\"Number: {val}\")\n    else:\n        print(f\"String: {val}\")\n\n# Callable (function types)\ndef apply_function(items: List[int], func: Callable[[int], int]) -> List[int]:\n    return [func(item) for item in items]\n\n# Any type (use sparingly)\ndef debug_print(data: Any) -> None:\n    print(f\"Data: {data}, Type: {type(data)}\")\n\n# Nested complex types\ndef process_data(data: Dict[str, List[Dict[str, int]]]) -> None:\n    for key, list_of_dicts in data.items():\n        print(f\"{key}: {list_of_dicts}\")\n\n# Example usage\ndata = {\n    \"group1\": [{\"value\": 1}, {\"value\": 2}],\n    \"group2\": [{\"value\": 3}]\n}\nprocess_data(data)\n```\n\n#### TypedDict for Complex Dictionaries\n\n```python\nfrom typing import TypedDict\n\n# Define structure of dictionary\nclass UserInfo(TypedDict):\n    name: str\n    age: int\n    email: str\n\ndef process_user(user: UserInfo) -> str:\n    return f\"{user['name']} ({user['age']}) - {user['email']}\"\n\nuser_data: UserInfo = {\n    \"name\": \"Alice\",\n    \"age\": 25,\n    \"email\": \"alice@example.com\"\n}\n\nprint(process_user(user_data))\n\n# With optional fields\nclass OptionalUserInfo(TypedDict, total=False):\n    name: str\n    phone: str  # Optional\n\nuser2: OptionalUserInfo = {\"name\": \"Bob\"}  # phone is optional\n```\n\n---\n\n### Special Cases and Edge Cases\n\n#### String Interning and Small Integer Caching\n\n```python\n# Small integers are cached\na = 256\nb = 256\nprint(a is b)  # True (same object)\n\nc = 257\nd = 257\nprint(c is d)  # False (different objects, but equal)\nprint(c == d)  # True\n\n# Strings are interned in some cases\ns1 = \"hello\"\ns2 = \"hello\"\nprint(s1 is s2)  # True (interned)\n\ns3 = \"hello\" + \" world\"\ns4 = \"hello world\"\nprint(s3 is s4)  # False (different creation methods)\nprint(s3 == s4)  # True\n```\n\n#### Comparing Complex Nested Structures\n\n```python\n# Deep equality comparison\ndata1 = {\n    \"users\": [\n        {\"name\": \"Alice\", \"scores\": [85, 90, 92]},\n        {\"name\": \"Bob\", \"scores\": [78, 82]}\n    ]\n}\n\ndata2 = {\n    \"users\": [\n        {\"name\": \"Alice\", \"scores\": [85, 90, 92]},\n        {\"name\": \"Bob\", \"scores\": [78, 82]}\n    ]\n}\n\nprint(data1 == data2)      # True (deep equality)\nprint(data1 is data2)      # False (different objects)\n\n# Both structures have identical content\n```\n\n#### NaN and Special Float Values in Collections\n\n```python\n# NaN is special: NaN != NaN\nvalues = [1.0, float('nan'), 2.0]\nprint(float('nan') in values)  # True (despite NaN != NaN)\n\n# But in sets/dicts it's problematic\ndata_set = {1.0, float('nan'), float('nan')}\nprint(len(data_set))  # 3! (NaN hash varies, creates multiple entries)\n\n# Better to use None or special sentinel\ndata_set = {1.0, None, 2.0}\nprint(len(data_set))  # 3\n```\n\n#### Circular References\n\n```python\n# Lists can contain themselves\nmy_list = [1, 2, 3]\nmy_list.append(my_list)  # Circular reference\nprint(my_list)  # [1, 2, 3, [...]]\n\n# Dictionaries can contain themselves\nmy_dict = {\"a\": 1}\nmy_dict[\"self\"] = my_dict  # Circular reference\n\n# Python handles these with garbage collection\n# But be aware of memory implications\n```\n\n---\n\n### Advanced Iteration and Comprehensions\n\n#### Generator Expressions vs List Comprehensions\n\n```python\n# List comprehension: creates entire list in memory\nlist_comp = [x**2 for x in range(1000000)]\nprint(type(list_comp))  # <class 'list'>\n# All 1,000,000 items in memory\n\n# Generator expression: creates items on demand\ngen_expr = (x**2 for x in range(1000000))\nprint(type(gen_expr))  # <class 'generator'>\n# Lazy evaluation, much more memory efficient\n\n# Use generators for large datasets\nfor value in gen_expr:\n    if value > 1000000:\n        break  # Stops early, doesn't compute rest\n\n# Generator vs List: memory comparison\nimport sys\nlist_comp = [x for x in range(100000)]\ngen_expr = (x for x in range(100000))\n\nprint(f\"List: {sys.getsizeof(list_comp)} bytes\")\nprint(f\"Generator: {sys.getsizeof(gen_expr)} bytes\")  # Much smaller!\n```\n\n#### Complex Dictionary Comprehensions\n\n```python\n# Grouping by key\nstudents = [\n    {\"name\": \"Alice\", \"grade\": \"A\"},\n    {\"name\": \"Bob\", \"grade\": \"B\"},\n    {\"name\": \"Charlie\", \"grade\": \"A\"},\n]\n\n# Group by grade\nby_grade = {}\nfor student in students:\n    grade = student[\"grade\"]\n    if grade not in by_grade:\n        by_grade[grade] = []\n    by_grade[grade].append(student[\"name\"])\n\nprint(by_grade)  # {'A': ['Alice', 'Charlie'], 'B': ['Bob']}\n\n# More elegant with defaultdict and comprehension\nfrom collections import defaultdict\nby_grade = defaultdict(list)\nfor student in students:\n    by_grade[student[\"grade\"]].append(student[\"name\"])\n\nprint(dict(by_grade))  # Same result\n\n# Or with groupby from itertools\nfrom itertools import groupby\nstudents_sorted = sorted(students, key=lambda s: s[\"grade\"])\nby_grade = {k: [s[\"name\"] for s in g] for k, g in groupby(students_sorted, key=lambda s: s[\"grade\"])}\nprint(by_grade)  # Same result\n```\n\n---\n\n### Thread Safety and Collections\n\n#### Which Collections Are Thread-Safe?\n\n```python\nimport threading\nimport time\n\n# Lists are NOT fully thread-safe (interpreter lock helps but not guaranteed)\ndef test_list_threading():\n    my_list = []\n    \n    def append_items():\n        for i in range(1000):\n            my_list.append(i)\n    \n    threads = [threading.Thread(target=append_items) for _ in range(5)]\n    for thread in threads:\n        thread.start()\n    for thread in threads:\n        thread.join()\n    \n    # Should have 5000 items, but might have race conditions\n    print(f\"Expected 5000, got {len(my_list)}\")\n\n# For thread-safe operations, use queue.Queue\nfrom queue import Queue\n\nq = Queue()  # Thread-safe queue\ndef producer():\n    for i in range(5):\n        q.put(i)  # Thread-safe\n\ndef consumer():\n    while True:\n        item = q.get()  # Thread-safe\n        print(f\"Consumed: {item}\")\n        q.task_done()\n\n# Use thread.local() for thread-local storage\nimport threading\nlocal_data = threading.local()\nlocal_data.my_list = []  # Each thread gets own copy\n```\n\n---\n\n### Common Gotchas and Solutions\n\n#### Gotcha 1: Dictionary Ordering in Python < 3.7\n\n```python\n# Python 3.7+: dictionaries maintain insertion order\ndata = {\"z\": 1, \"a\": 2, \"m\": 3}\nprint(list(data.keys()))  # ['z', 'a', 'm'] in order\n\n# Python < 3.7: order was unpredictable\n# Solution: use collections.OrderedDict\nfrom collections import OrderedDict\ndata = OrderedDict([(\"z\", 1), (\"a\", 2), (\"m\", 3)])\n```\n\n#### Gotcha 2: Set Operations with Different Sizes\n\n```python\n# For set difference, order matters\nset_a = {1, 2, 3, 4, 5}\nset_b = {4, 5, 6, 7}\n\nprint(set_a - set_b)  # {1, 2, 3} elements in a but not b\nprint(set_b - set_a)  # {6, 7} elements in b but not a\n\n# Intersection is commutative\nprint(set_a & set_b)  # {4, 5}\nprint(set_b & set_a)  # {4, 5}\n```\n\n#### Gotcha 3: Updating Dictionary While Iterating\n\n```python\n# WRONG: RuntimeError in Python 3\ndata = {\"a\": 1, \"b\": 2, \"c\": 3}\nfor key, value in data.items():\n    if key == \"b\":\n        data[\"d\"] = 4  # RuntimeError: dictionary changed size during iteration\n\n# CORRECT: Create copy of items to iterate\ndata = {\"a\": 1, \"b\": 2, \"c\": 3}\nfor key, value in list(data.items()):  # Convert to list first\n    if key == \"b\":\n        data[\"d\"] = 4  # OK\n\nprint(data)  # {'a': 1, 'b': 2, 'c': 3, 'd': 4}\n```\n\n#### Gotcha 4: Sorted on Different Types\n\n```python\n# Sorting mixed types raises TypeError in Python 3\nmixed = [3, \"apple\", 1.5, True]\n# sorted(mixed)  # TypeError: '<' not supported between instances\n\n# Solution: sort by type or convert to same type\nmixed = [3, \"apple\", 1.5, True]\nsorted_by_type = sorted(mixed, key=lambda x: (type(x).__name__, x))\n# [(True, True), (1.5, 1.5), (3, 3), ('apple', 'apple')]\n```",
  "cheatsheet": "## Data Types & Structures: Quick Reference\n\n### Core Data Types at a Glance\n\n| Type | Mutable | Ordered | Indexed | Hashable | Use For |\n|------|---------|---------|---------|----------|----------|\n| **List** | Yes | Yes | Yes | No | Ordered collections, frequent changes |\n| **Tuple** | No | Yes | Yes | Yes | Immutable data, dict keys, unpacking |\n| **Dict** | Yes | Yes* | No | No | Key-value mapping |\n| **Set** | Yes | No | No | No | Unique items, set operations |\n| **Frozenset** | No | No | No | Yes | Immutable set, set of sets |\n\n*Python 3.7+\n\n---\n\n### List Operations\n\n```python\n# Creation\nmy_list = [1, 2, 3]\nmy_list = list([1, 2, 3])\nmy_list = [x for x in range(5)]  # [0, 1, 2, 3, 4]\n\n# Access & Slice\nmy_list[0]           # First element\nmy_list[-1]          # Last element\nmy_list[1:3]         # Slice [start:stop)\nmy_list[::2]         # Every 2nd element\nmy_list[::-1]        # Reversed\n\n# Modify\nmy_list.append(4)            # Add to end O(1)\nmy_list.extend([5, 6])       # Add multiple O(k)\nmy_list.insert(0, 0)         # Insert at index O(n)\nmy_list[0] = 99              # Replace element O(1)\nmy_list.remove(99)           # Remove first occurrence O(n)\nmy_list.pop()                # Remove last O(1)\nmy_list.pop(0)               # Remove first O(n)\nmy_list.clear()              # Remove all O(n)\n\n# Query\nlen(my_list)                 # Length\n2 in my_list                 # Membership O(n)\nmy_list.count(2)             # Count occurrences O(n)\nmy_list.index(2)             # Find index O(n)\n\n# Sort & Reverse\nmy_list.sort()               # In-place sort O(n log n)\nmy_list.sort(reverse=True)   # Descending\nmy_list.sort(key=lambda x: x**2)  # By custom key\nmy_list.reverse()            # In-place reverse O(n)\n\n# Copy\nshallow = my_list.copy()     # Shallow copy\nshallow = list(my_list)      # Also shallow copy\nimport copy\ndeep = copy.deepcopy(my_list)  # Deep copy\n```\n\n---\n\n### Tuple Operations\n\n```python\n# Creation\nmy_tuple = (1, 2, 3)\nmy_tuple = tuple([1, 2, 3])\nsingle = (42,)               # Important: comma for single element\nempty = ()\n\n# Access & Unpack\nmy_tuple[0]                  # First element\nmy_tuple[-1]                 # Last element\nx, y, z = my_tuple           # Unpack all\nfirst, *middle, last = my_tuple  # Unpack with *\nname, _ = (\"Alice\", 25)      # Ignore values with _\n\n# Query (only two methods!)\nmy_tuple.count(2)            # Count occurrences\nmy_tuple.index(2)            # Find index\n\n# Immutable - no modification\n# Can't: append, extend, remove, pop, sort, reverse\n# Instead: tuple = tuple + (new_item,)\n\n# Use as Dict Key\ndata = {(1, 2): \"value\"}     # Tuples work as keys\n\n# Return Multiple Values\ndef get_values():\n    return (1, 2, 3)\na, b, c = get_values()\n```\n\n---\n\n### Dictionary Operations\n\n```python\n# Creation\nmy_dict = {\"a\": 1, \"b\": 2}\nmy_dict = dict(a=1, b=2)\nmy_dict = dict([(\"a\", 1), (\"b\", 2)])\nempty = {}\n\n# Access\nmy_dict[\"a\"]                 # Get value, error if missing\nmy_dict.get(\"a\")             # Get value, None if missing\nmy_dict.get(\"a\", \"default\")  # Get with default\n\"a\" in my_dict               # Check key exists O(1)\n\n# Modify\nmy_dict[\"c\"] = 3             # Add or update\nmy_dict.update({\"d\": 4})     # Merge another dict\nmy_dict.setdefault(\"e\", 5)   # Set if missing, return value\ndel my_dict[\"a\"]             # Delete by key\nmy_dict.pop(\"b\")             # Remove and return value\nmy_dict.pop(\"b\", \"default\")  # Remove with default\nmy_dict.popitem()            # Remove last inserted pair\nmy_dict.clear()              # Remove all\n\n# Query\nlen(my_dict)                 # Number of items\nmy_dict.keys()               # All keys\nmy_dict.values()             # All values\nmy_dict.items()              # Key-value pairs\n\n# Iterate\nfor key in my_dict:          # Iterate keys\nfor key, value in my_dict.items():  # Iterate pairs\n\n# Copy\nshallow = my_dict.copy()     # Shallow copy\nimport copy\ndeep = copy.deepcopy(my_dict)  # Deep copy\n\n# Comprehension\n{k: v**2 for k, v in my_dict.items()}  # Transform\n{k: v for k, v in my_dict.items() if v > 2}  # Filter\n```\n\n---\n\n### Set Operations\n\n```python\n# Creation\nmy_set = {1, 2, 3}\nmy_set = set([1, 2, 2, 3])   # Removes duplicates\nempty = set()                # Important: not {}\nfrozen = frozenset([1, 2, 3])  # Immutable set\n\n# Modify (frozen sets cannot modify)\nmy_set.add(4)                # Add element O(1)\nmy_set.update({5, 6})        # Add multiple O(k)\nmy_set.remove(1)             # Remove, error if missing\nmy_set.discard(1)            # Remove, no error if missing\nmy_set.pop()                 # Remove random element\nmy_set.clear()               # Remove all\n\n# Query\nlen(my_set)                  # Size\n1 in my_set                  # Membership O(1)\nmy_set.isdisjoint({7, 8})    # No common elements\nmy_set.issubset({1, 2, 3, 4})   # All in other\nmy_set.issuperset({1, 2})    # Contains all of other\n\n# Operations\nset_a = {1, 2, 3}\nset_b = {3, 4, 5}\n\nset_a | set_b               # Union {1, 2, 3, 4, 5}\nset_a.union(set_b)          # Same\n\nset_a & set_b               # Intersection {3}\nset_a.intersection(set_b)   # Same\n\nset_a - set_b               # Difference {1, 2}\nset_a.difference(set_b)     # Same\n\nset_a ^ set_b               # Symmetric difference {1, 2, 4, 5}\nset_a.symmetric_difference(set_b)  # Same\n\n# In-place operations\nset_a.update(set_b)         # Union in-place\nset_a.intersection_update(set_b)  # Keep only common\nset_a.difference_update(set_b)    # Remove common\nset_a.symmetric_difference_update(set_b)  # Keep non-common\n\n# Remove duplicates from list\nunique = list(set(my_list))  # Order not guaranteed\nunique = list(dict.fromkeys(my_list))  # Preserves order\n```\n\n---\n\n### Collections Module\n\n```python\nfrom collections import namedtuple, defaultdict, Counter, deque, OrderedDict\n\n# namedtuple - tuple with named fields\nPoint = namedtuple('Point', ['x', 'y'])\np = Point(10, 20)\nprint(p.x, p.y)             # Accessible by name\nprint(p[0], p[1])           # Still indexable\n\n# defaultdict - dict with default factory\nword_count = defaultdict(int)\nfor word in \"apple banana apple\".split():\n    word_count[word] += 1    # No KeyError\n\nword_count = defaultdict(list)\nword_count[\"fruits\"].append(\"apple\")  # Auto-creates list\n\n# Counter - specialized dict for counting\nfruits = [\"apple\", \"banana\", \"apple\"]\ncount = Counter(fruits)\nprint(count[\"apple\"])        # 2\nprint(count.most_common(2))  # [('apple', 2), ('banana', 1)]\nprint(sum(count.values()))   # Total count\n\n# deque - double-ended queue, efficient popleft\nq = deque([1, 2, 3])\nq.append(4)                  # Add right O(1)\nq.appendleft(0)              # Add left O(1)\nq.pop()                      # Remove right O(1)\nq.popleft()                  # Remove left O(1)\nq.rotate(1)                  # Rotate right\n\n# OrderedDict - maintains insertion order (Python 3.7+ use dict)\nod = OrderedDict()\nod[\"z\"] = 1\nod[\"a\"] = 2\nprint(list(od.keys()))       # ['z', 'a'] - order preserved\n```\n\n---\n\n### Type Hints\n\n```python\nfrom typing import List, Dict, Set, Tuple, Optional, Union, Any\n\n# Collections\ndef process_list(items: List[int]) -> None:\n    pass\n\ndef create_dict(keys: List[str]) -> Dict[str, int]:\n    pass\n\ndef get_unique(items: List[str]) -> Set[str]:\n    pass\n\ndef get_coordinates() -> Tuple[int, int]:\n    pass\n\n# Optional (nullable)\ndef find_item(items: List[int], target: int) -> Optional[int]:\n    return next((i for i, x in enumerate(items) if x == target), None)\n\n# Union (multiple types)\ndef process(value: Union[int, str]) -> None:\n    pass\n\n# Any (avoid using)\ndef debug(data: Any) -> None:\n    pass\n\n# Callable (function types)\nfrom typing import Callable\ndef apply(func: Callable[[int], int], items: List[int]) -> List[int]:\n    return [func(x) for x in items]\n\n# TypedDict (structure for dicts)\nfrom typing import TypedDict\n\nclass User(TypedDict):\n    name: str\n    age: int\n    email: str\n\ndef process_user(user: User) -> str:\n    return user[\"name\"]\n```\n\n---\n\n### Performance at a Glance\n\n```\nLIST Operations:             O(1)  O(n)  O(n)  O(n)  O(n log n)\n                           append insert pop   search   sort\n\nDICT Operations:             O(1)  O(1)  O(1)  O(1)   \n                           add    set   get   check\n                           (average case)\n\nSET Operations:              O(1)  O(1)  O(1)  O(1)   O(n)\n                           add    remove check union\n\nMEMORY OVERHEAD (for 1000 items):\nList:       ~9 KB\nDict:      ~49 KB  (much higher due to hashing overhead)\nSet:       ~49 KB  (same as dict)\nTuple:      ~9 KB  (similar to list, but immutable)\n```\n\n---\n\n### Decision Tree\n\n```\n1. Need key-value pairs?\n   YES → Dictionary\n   NO ↓\n\n2. Need unique items only?\n   YES → Set\n   NO ↓\n\n3. Need mutability?\n   YES → List\n   NO → Tuple\n```\n\n---\n\n### Common Mistakes Quick Fix\n\n```python\n# MISTAKE: Empty set\nwrong = {}       # This is dict!\ncorrect = set()  # This is set\n\n# MISTAKE: Mutable default argument\nwrong = def func(items=[]):      # Dangerous!\ncorrect = def func(items=None):\n    if items is None: items = []\n\n# MISTAKE: Modifying while iterating\nwrong = for x in mylist: mylist.remove(x)\ncorrect = mylist = [x for x in mylist if condition]\n\n# MISTAKE: Shallow copy of nested structure\nwrong = copied = original.copy()     # Nested items still shared\ncorrect = import copy; copied = copy.deepcopy(original)\n\n# MISTAKE: List as dict key\nwrong = {[1, 2]: \"value\"}  # TypeError!\ncorrect = {(1, 2): \"value\"}  # Use tuple\n\n# MISTAKE: Assuming dict order (Python < 3.7)\nwrong = dict order not guaranteed\ncorrect = use OrderedDict or Python 3.7+\n\n# MISTAKE: O(n) operations in loop\nwrong = for x in mylist:\n        if x in mylist:  # O(n) each time!\ncorrect = mylist_set = set(mylist)\n         for x in mylist_set:\n             if x in mylist_set:  # O(1)\n```\n\n---\n\n### Syntax Quick Reference\n\n```python\n# Unpacking\na, b = (1, 2)\na, b, c = [1, 2, 3]\nfirst, *rest = [1, 2, 3]  # first=1, rest=[2, 3]\nfirst, *middle, last = range(5)  # Flexible unpacking\n\n# Swapping\na, b = b, a  # Uses tuple unpacking\n\n# Multiple return values\ndef func():\n    return (1, 2, 3)  # Returns tuple\na, b, c = func()     # Unpacks automatically\n\n# List slicing\nmy_list[start:stop:step]  # From start (inclusive) to stop (exclusive) by step\nmy_list[:3]               # First 3 items\nmy_list[3:]               # From item 3 to end\nmy_list[-3:]              # Last 3 items\nmy_list[::2]              # Every 2nd item\nmy_list[::-1]             # Reversed\n\n# Dict get with default\nmy_dict.get(key, default_value)\nmy_dict.get(key)  # Returns None if missing\n\n# Set membership (fast!)\nif item in my_set:  # O(1)\nif item in my_list:  # O(n)\n\n# Check/set default in dict\nif key not in my_dict:\n    my_dict[key] = value\n\n# Or use setdefault\nmy_dict.setdefault(key, value)\n```"
}
