{
  "beginner": "## Decorators: Beginner Level\n\n### 1. What is a Decorator?\n\nA decorator is a function that modifies or enhances another function without changing its source code. Think of it like wrapping a gift - the gift stays the same, but it's now presented in a nicer way.\n\n```python\n# Simple example: function as an object\ndef greet():\n    return \"Hello!\"\n\n# Functions are objects - we can pass them around\nmy_function = greet\nprint(my_function())  # Output: Hello!\n```\n\n###  2. First Decorator: Understanding the Basics\n\nLet's create the simplest possible decorator.\n\n```python\n# A decorator is a function that takes a function and returns a function\ndef my_decorator(func):\n    def wrapper():\n        print(\"Before the function\")\n        func()  # Call the original function\n        print(\"After the function\")\n    return wrapper\n\n# Without @ syntax (manual decoration)\ndef say_hello():\n    print(\"Hello!\")\n\nsay_hello = my_decorator(say_hello)  # Decorate manually\nsay_hello()\n# Output:\n# Before the function\n# Hello!\n# After the function\n```\n\n### 3. The @ Syntax\n\nPython provides a cleaner syntax using `@` to apply decorators.\n\n```python\ndef my_decorator(func):\n    def wrapper():\n        print(\"Before the function\")\n        func()\n        print(\"After the function\")\n    return wrapper\n\n# Using @ syntax (same as manual decoration above)\n@my_decorator\ndef say_hello():\n    print(\"Hello!\")\n\nsay_hello()\n# Output:\n# Before the function\n# Hello!\n# After the function\n\n# The @ syntax is just syntactic sugar for:\n# say_hello = my_decorator(say_hello)\n```\n\n### 4. Key Takeaways\n\n- Decorators modify functions without changing their code\n- Use `@decorator_name` syntax above a function definition\n- Always use `*args, **kwargs` in wrapper to handle any function signature\n- Always return the result from the wrapper function\n- Built-in decorators: `@property`, `@staticmethod`, `@classmethod`\n",
  "intermediate": "## Decorators: Intermediate Level\n\n### 1. Understanding functools.wraps\n\nPreserves function metadata when decorating.\n\n### 2. Parameterized Decorators\n\nDecorators that accept arguments require an additional layer of functions.\n\n### 3. Decorator Chaining\n\nMultiple decorators applied bottom-to-top.\n",
  "advanced": "## Decorators: Advanced Level\n\n### 1. Deep Dive into Decorator Mechanics\n\nUnderstanding how decorators work under the hood.\n\n### 2. Class-Based Decorators\n\nUsing classes as decorators with `__call__` method.\n\n### 3. Performance Optimization\n\nTechniques for efficient decorators.\n",
  "cheatsheet": "## Decorators: Cheatsheet\n\n### Basic Decorator Template\n\n```python\nimport functools\n\ndef my_decorator(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        result = func(*args, **kwargs)\n        return result\n    return wrapper\n```\n\n### Common Patterns\n\n- Logging: Track function calls\n- Timing: Measure execution time\n- Caching: Store results for reuse\n- Validation: Check arguments\n- Authorization: Control access\n"
}