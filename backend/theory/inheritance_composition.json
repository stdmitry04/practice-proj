{
  "beginner": "## Inheritance & Composition: Beginner Level\n\n### Understanding Inheritance\n\nInheritance allows a class to inherit attributes and methods from another class. The class being inherited from is called the **parent** or **base** class, and the class inheriting is called the **child** or **derived** class.\n\n#### Why Use Inheritance?\n\n1. **Code Reuse**: Avoid duplicating code across similar classes\n2. **Logical Hierarchy**: Model real-world relationships (is-a relationships)\n3. **Extensibility**: Add or override functionality in child classes\n4. **Polymorphism**: Treat objects of different classes uniformly\n\n```python\n# Without inheritance - code duplication\nclass Dog:\n    def __init__(self, name):\n        self.name = name\n    \n    def eat(self):\n        print(f\"{self.name} is eating\")\n    \n    def bark(self):\n        print(f\"{self.name} barks: Woof!\")\n\nclass Cat:\n    def __init__(self, name):\n        self.name = name\n    \n    def eat(self):  # Duplicated!\n        print(f\"{self.name} is eating\")\n    \n    def meow(self):\n        print(f\"{self.name} meows: Meow!\")\n\n# With inheritance - code reuse\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n    \n    def eat(self):\n        print(f\"{self.name} is eating\")\n\nclass Dog(Animal):  # Inherits from Animal\n    def bark(self):\n        print(f\"{self.name} barks: Woof!\")\n\nclass Cat(Animal):  # Inherits from Animal\n    def meow(self):\n        print(f\"{self.name} meows: Meow!\")\n\ndog = Dog(\"Buddy\")\ndog.eat()   # Inherited method\ndog.bark()  # Own method\n```\n\n---\n\n### Basic Inheritance Syntax\n\n#### Creating a Parent Class\n\n```python\nclass Vehicle:\n    def __init__(self, brand, model):\n        self.brand = brand\n        self.model = model\n    \n    def start(self):\n        print(f\"{self.brand} {self.model} starting...\")\n    \n    def stop(self):\n        print(f\"{self.brand} {self.model} stopping...\")\n```\n\n#### Creating a Child Class\n\n```python\nclass Car(Vehicle):  # Car inherits from Vehicle\n    def honk(self):\n        print(\"Honk honk!\")\n\n# Car has access to all Vehicle methods\nmy_car = Car(\"Toyota\", \"Camry\")\nmy_car.start()  # Inherited from Vehicle\nmy_car.honk()   # Defined in Car\nmy_car.stop()   # Inherited from Vehicle\n```\n\n---\n\n### The super() Function\n\nThe `super()` function allows you to call methods from the parent class.\n\n#### Extending the Parent Constructor\n\n```python\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n        print(f\"Animal created: {name}\")\n\nclass Dog(Animal):\n    def __init__(self, name, breed):\n        super().__init__(name)  # Call parent constructor\n        self.breed = breed\n        print(f\"Dog breed: {breed}\")\n\ndog = Dog(\"Max\", \"Golden Retriever\")\n# Output:\n# Animal created: Max\n# Dog breed: Golden Retriever\nprint(dog.name)   # Max\nprint(dog.breed)  # Golden Retriever\n```\n\n#### Calling Parent Methods\n\n```python\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    \n    def introduce(self):\n        print(f\"Hi, I'm {self.name}, {self.age} years old\")\n\nclass Student(Person):\n    def __init__(self, name, age, student_id):\n        super().__init__(name, age)\n        self.student_id = student_id\n    \n    def introduce(self):\n        super().introduce()  # Call parent method\n        print(f\"My student ID is {self.student_id}\")\n\nstudent = Student(\"Alice\", 20, \"S12345\")\nstudent.introduce()\n# Output:\n# Hi, I'm Alice, 20 years old\n# My student ID is S12345\n```\n\n---\n\n### Method Overriding\n\nChild classes can override parent methods to provide specific behavior.\n\n```python\nclass Shape:\n    def area(self):\n        return 0\n    \n    def describe(self):\n        print(\"This is a shape\")\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):  # Override parent method\n        return self.width * self.height\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n    \n    def area(self):  # Override parent method\n        return 3.14 * self.radius ** 2\n\nrect = Rectangle(5, 3)\nprint(rect.area())  # 15 (overridden method)\n\ncircle = Circle(4)\nprint(circle.area())  # 50.24 (overridden method)\n```\n\n---\n\n### Introduction to Composition\n\n**Composition** means building complex objects by combining simpler objects. Instead of \"is-a\" (inheritance), composition represents \"has-a\" relationships.\n\n```python\n# Composition: Car HAS an Engine\nclass Engine:\n    def __init__(self, horsepower):\n        self.horsepower = horsepower\n    \n    def start(self):\n        print(f\"Engine with {self.horsepower}hp starting...\")\n\nclass Car:\n    def __init__(self, brand, horsepower):\n        self.brand = brand\n        self.engine = Engine(horsepower)  # Composition\n    \n    def start(self):\n        print(f\"{self.brand} starting...\")\n        self.engine.start()  # Delegate to engine\n\nmy_car = Car(\"Toyota\", 200)\nmy_car.start()\n# Output:\n# Toyota starting...\n# Engine with 200hp starting...\n```\n\n---\n\n### When to Use Inheritance vs Composition\n\n#### Use Inheritance When:\n- You have a clear \"is-a\" relationship\n- You want to share behavior across related classes\n- You need polymorphism (treating different objects uniformly)\n\n```python\nclass Employee:  # Base class\n    def work(self):\n        print(\"Working...\")\n\nclass Developer(Employee):  # IS-A Employee\n    def code(self):\n        print(\"Writing code...\")\n\nclass Designer(Employee):  # IS-A Employee\n    def design(self):\n        print(\"Creating designs...\")\n```\n\n#### Use Composition When:\n- You have a \"has-a\" relationship\n- You want more flexibility and loose coupling\n- You need to change behavior at runtime\n\n```python\nclass Keyboard:\n    def type(self):\n        print(\"Typing...\")\n\nclass Mouse:\n    def click(self):\n        print(\"Clicking...\")\n\nclass Computer:\n    def __init__(self):\n        self.keyboard = Keyboard()  # HAS-A Keyboard\n        self.mouse = Mouse()        # HAS-A Mouse\n    \n    def use(self):\n        self.keyboard.type()\n        self.mouse.click()\n\ncomp = Computer()\ncomp.use()\n```\n\n---\n\n### isinstance() and issubclass()\n\nCheck object types and class relationships.\n\n```python\nclass Animal:\n    pass\n\nclass Dog(Animal):\n    pass\n\ndog = Dog()\n\n# isinstance: check if object is instance of class\nprint(isinstance(dog, Dog))     # True\nprint(isinstance(dog, Animal))  # True (inherited)\nprint(isinstance(dog, str))     # False\n\n# issubclass: check if class inherits from another\nprint(issubclass(Dog, Animal))  # True\nprint(issubclass(Animal, Dog))  # False\nprint(issubclass(Dog, Dog))     # True\n```\n\n---\n\n### Common Beginner Mistakes\n\n#### Mistake 1: Forgetting super() in Child __init__\n\n```python\n# WRONG\nclass Parent:\n    def __init__(self, name):\n        self.name = name\n\nclass Child(Parent):\n    def __init__(self, name, age):\n        self.age = age  # Forgot super()!\n        # self.name not initialized!\n\n# CORRECT\nclass Child(Parent):\n    def __init__(self, name, age):\n        super().__init__(name)  # Initialize parent\n        self.age = age\n```\n\n#### Mistake 2: Circular Inheritance\n\n```python\n# WRONG - causes error\n# class A(B):\n#     pass\n# \n# class B(A):  # TypeError: Cannot create circular reference\n#     pass\n```\n\n#### Mistake 3: Confusing Inheritance with Composition\n\n```python\n# WRONG - Car is not a Engine!\nclass Car(Engine):\n    pass\n\n# CORRECT - Car HAS an Engine\nclass Car:\n    def __init__(self):\n        self.engine = Engine()\n```",
  "intermediate": "## Inheritance & Composition: Intermediate Level\n\n### Method Resolution Order (MRO)\n\nPython uses the **C3 Linearization** algorithm to determine the order in which base classes are searched when looking for a method.\n\n#### Viewing MRO\n\n```python\nclass A:\n    pass\n\nclass B(A):\n    pass\n\nclass C(A):\n    pass\n\nclass D(B, C):\n    pass\n\nprint(D.__mro__)\n# (<class 'D'>, <class 'B'>, <class 'C'>, <class 'A'>, <class 'object'>)\n\nprint(D.mro())\n# [<class 'D'>, <class 'B'>, <class 'C'>, <class 'A'>, <class 'object'>]\n```\n\n#### MRO in Action\n\n```python\nclass A:\n    def method(self):\n        print(\"A.method\")\n\nclass B(A):\n    def method(self):\n        print(\"B.method\")\n\nclass C(A):\n    def method(self):\n        print(\"C.method\")\n\nclass D(B, C):\n    pass\n\nd = D()\nd.method()  # B.method (MRO: D -> B -> C -> A)\n\n# D doesn't have method, so check B (found!)\n```\n\n---\n\n### Multiple Inheritance\n\nA class can inherit from multiple parent classes.\n\n#### Basic Multiple Inheritance\n\n```python\nclass Flyer:\n    def fly(self):\n        print(\"Flying...\")\n\nclass Swimmer:\n    def swim(self):\n        print(\"Swimming...\")\n\nclass Duck(Flyer, Swimmer):\n    def quack(self):\n        print(\"Quack!\")\n\nduck = Duck()\nduck.fly()    # From Flyer\nduck.swim()   # From Swimmer\nduck.quack()  # From Duck\n```\n\n#### Diamond Problem\n\nWhen multiple inheritance creates a diamond shape, MRO ensures each class is called only once.\n\n```python\nclass A:\n    def __init__(self):\n        print(\"A.__init__\")\n        super().__init__()\n\nclass B(A):\n    def __init__(self):\n        print(\"B.__init__\")\n        super().__init__()\n\nclass C(A):\n    def __init__(self):\n        print(\"C.__init__\")\n        super().__init__()\n\nclass D(B, C):\n    def __init__(self):\n        print(\"D.__init__\")\n        super().__init__()\n\nd = D()\n# Output (following MRO):\n# D.__init__\n# B.__init__\n# C.__init__\n# A.__init__\n\n# A is only called once!\nprint(D.__mro__)\n# D -> B -> C -> A -> object\n```\n\n---\n\n### Mixins\n\nMixins are classes that provide specific functionality to be added to other classes.\n\n```python\nclass TimestampMixin:\n    \"\"\"Adds timestamp functionality\"\"\"\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        from datetime import datetime\n        self.created_at = datetime.now()\n    \n    def get_age(self):\n        from datetime import datetime\n        return (datetime.now() - self.created_at).seconds\n\nclass SerializeMixin:\n    \"\"\"Adds JSON serialization\"\"\"\n    def to_dict(self):\n        return {k: v for k, v in self.__dict__.items() \n                if not k.startswith('_')}\n\nclass User(TimestampMixin, SerializeMixin):\n    def __init__(self, name, email):\n        super().__init__()\n        self.name = name\n        self.email = email\n\nuser = User(\"Alice\", \"alice@example.com\")\nprint(user.to_dict())  # From SerializeMixin\nprint(user.get_age())  # From TimestampMixin (seconds since creation)\n```\n\n---\n\n### Abstract Base Classes (ABC)\n\nABCs define a contract that subclasses must follow.\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        \"\"\"Calculate area - must be implemented by subclasses\"\"\"\n        pass\n    \n    @abstractmethod\n    def perimeter(self):\n        \"\"\"Calculate perimeter - must be implemented by subclasses\"\"\"\n        pass\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n    \n    def perimeter(self):\n        return 2 * (self.width + self.height)\n\n# Cannot instantiate abstract class\n# shape = Shape()  # TypeError\n\nrect = Rectangle(5, 3)\nprint(rect.area())       # 15\nprint(rect.perimeter())  # 16\n```\n\n---\n\n### Composition Patterns\n\n#### Dependency Injection\n\n```python\nclass EmailService:\n    def send(self, to, message):\n        print(f\"Sending email to {to}: {message}\")\n\nclass SMSService:\n    def send(self, to, message):\n        print(f\"Sending SMS to {to}: {message}\")\n\nclass NotificationManager:\n    def __init__(self, service):\n        self.service = service  # Inject dependency\n    \n    def notify(self, user, message):\n        self.service.send(user, message)\n\n# Use with email\nemail_notifier = NotificationManager(EmailService())\nemail_notifier.notify(\"user@example.com\", \"Hello!\")\n\n# Use with SMS\nsms_notifier = NotificationManager(SMSService())\nsms_notifier.notify(\"+1234567890\", \"Hello!\")\n```\n\n#### Strategy Pattern (Composition)\n\n```python\nclass PaymentStrategy:\n    def pay(self, amount):\n        raise NotImplementedError\n\nclass CreditCardPayment(PaymentStrategy):\n    def pay(self, amount):\n        print(f\"Paid ${amount} with credit card\")\n\nclass PayPalPayment(PaymentStrategy):\n    def pay(self, amount):\n        print(f\"Paid ${amount} with PayPal\")\n\nclass ShoppingCart:\n    def __init__(self):\n        self.payment_strategy = None\n    \n    def set_payment_strategy(self, strategy):\n        self.payment_strategy = strategy\n    \n    def checkout(self, amount):\n        if not self.payment_strategy:\n            raise ValueError(\"No payment method set\")\n        self.payment_strategy.pay(amount)\n\ncart = ShoppingCart()\ncart.set_payment_strategy(CreditCardPayment())\ncart.checkout(100)\n\ncart.set_payment_strategy(PayPalPayment())\ncart.checkout(50)\n```\n\n---\n\n### Cooperative super() Calls\n\nWhen using multiple inheritance, always use `super()` to ensure all classes in the MRO are called.\n\n```python\nclass Base:\n    def __init__(self):\n        print(\"Base.__init__\")\n\nclass A(Base):\n    def __init__(self):\n        print(\"A.__init__\")\n        super().__init__()  # Continues MRO chain\n\nclass B(Base):\n    def __init__(self):\n        print(\"B.__init__\")\n        super().__init__()  # Continues MRO chain\n\nclass C(A, B):\n    def __init__(self):\n        print(\"C.__init__\")\n        super().__init__()  # Starts MRO chain\n\nc = C()\n# Output follows MRO (C -> A -> B -> Base):\n# C.__init__\n# A.__init__\n# B.__init__\n# Base.__init__\n```\n\n---\n\n### Prefer Composition Over Inheritance\n\n#### Problem with Deep Inheritance\n\n```python\n# BAD: Deep inheritance hierarchy\nclass Animal:\n    pass\n\nclass Mammal(Animal):\n    pass\n\nclass Carnivore(Mammal):\n    pass\n\nclass Dog(Carnivore):\n    pass\n\n# Tight coupling, hard to modify\n```\n\n#### Better: Composition\n\n```python\n# GOOD: Composition for flexibility\nclass Diet:\n    pass\n\nclass Carnivorous(Diet):\n    def eat(self, food):\n        print(f\"Eating meat: {food}\")\n\nclass Herbivorous(Diet):\n    def eat(self, food):\n        print(f\"Eating plants: {food}\")\n\nclass Animal:\n    def __init__(self, name, diet):\n        self.name = name\n        self.diet = diet  # Composition\n    \n    def feed(self, food):\n        self.diet.eat(food)\n\ndog = Animal(\"Rex\", Carnivorous())\ndog.feed(\"chicken\")  # Eating meat: chicken\n\ncow = Animal(\"Bessie\", Herbivorous())\ncow.feed(\"grass\")    # Eating plants: grass\n```\n\n---\n\n### When to Use What: Decision Tree\n\n```\nDoes Class B need ALL functionality of Class A?\n  ├─ YES → Consider Inheritance (is-a)\n  │    ├─ Is it a true \"is-a\" relationship?\n  │    │    ├─ YES → Use Inheritance\n  │    │    └─ NO → Use Composition\n  │    └─\n  └─ NO → Use Composition (has-a)\n\nDo you need to add optional behaviors to a class?\n  └─ YES → Use Mixins or Composition\n\nDo you need to swap behaviors at runtime?\n  └─ YES → Use Composition (Strategy Pattern)\n\nDo you need to enforce a contract?\n  └─ YES → Use Abstract Base Classes\n```",
  "advanced": "## Inheritance & Composition: Advanced Level\n\n### Deep Dive: C3 Linearization\n\nPython uses the C3 Linearization algorithm to compute the Method Resolution Order (MRO).\n\n#### MRO Constraints\n\n```python\n# 1. Child before parent\n# 2. Parent order preserved from class definition\n# 3. Each class appears only once\n\nclass A: pass\nclass B: pass\nclass C(A, B): pass\nclass D(B, A): pass\n\n# This would fail:\n# class E(C, D): pass\n# TypeError: Cannot create consistent MRO\n# Because C says A before B, but D says B before A\n```\n\n#### Complex MRO Example\n\n```python\nclass A:\n    def method(self):\n        print(\"A\")\n\nclass B(A):\n    def method(self):\n        print(\"B\")\n        super().method()\n\nclass C(A):\n    def method(self):\n        print(\"C\")\n        super().method()\n\nclass D(B, C):\n    def method(self):\n        print(\"D\")\n        super().method()\n\nd = D()\nd.method()\n# Output: D, B, C, A\n# MRO: D -> B -> C -> A -> object\n\nprint([cls.__name__ for cls in D.__mro__])\n# ['D', 'B', 'C', 'A', 'object']\n```\n\n---\n\n### Metaclass Inheritance\n\nMetaclasses are inherited like regular classes.\n\n```python\nclass Meta(type):\n    def __new__(mcs, name, bases, attrs):\n        print(f\"Creating class: {name}\")\n        attrs['class_id'] = id(name)\n        return super().__new__(mcs, name, bases, attrs)\n\nclass Base(metaclass=Meta):\n    pass\n# Output: Creating class: Base\n\nclass Child(Base):\n    pass\n# Output: Creating class: Child\n# Child inherits Meta metaclass\n\nprint(Child.class_id)  # Some ID\n```\n\n---\n\n### Multiple Inheritance Conflicts\n\n#### Attribute Conflicts\n\n```python\nclass A:\n    value = \"A\"\n\nclass B:\n    value = \"B\"\n\nclass C(A, B):\n    pass\n\nprint(C.value)  # \"A\" (first in MRO)\nprint(C.__mro__)\n# C -> A -> B -> object\n```\n\n#### Method Conflicts\n\n```python\nclass Printer:\n    def print(self, text):\n        print(f\"Printer: {text}\")\n\nclass Logger:\n    def print(self, text):\n        print(f\"Logger: {text}\")\n\nclass Device(Printer, Logger):\n    pass\n\nd = Device()\nd.print(\"test\")  # Printer: test (first in MRO)\n\n# To call Logger.print specifically:\nLogger.print(d, \"test\")  # Logger: test\n```\n\n---\n\n### Virtual Subclasses\n\nRegister a class as a virtual subclass without actual inheritance.\n\n```python\nfrom abc import ABC\n\nclass Drawable(ABC):\n    def draw(self):\n        pass\n\nclass Circle:\n    def draw(self):\n        print(\"Drawing circle\")\n\n# Register Circle as virtual subclass\nDrawable.register(Circle)\n\nprint(issubclass(Circle, Drawable))  # True\nprint(isinstance(Circle(), Drawable))  # True\n\n# But Circle doesn't inherit from Drawable!\nprint(Circle.__mro__)\n# [Circle, object] - no Drawable\n```\n\n---\n\n### Advanced Composition: Descriptor-Based\n\n```python\nclass Component:\n    def __init__(self, name):\n        self.name = name\n    \n    def __get__(self, obj, objtype=None):\n        if obj is None:\n            return self\n        return obj.__dict__.get(self.name)\n    \n    def __set__(self, obj, value):\n        obj.__dict__[self.name] = value\n\nclass Engine:\n    def start(self):\n        return \"Engine starting\"\n\nclass Wheels:\n    def roll(self):\n        return \"Wheels rolling\"\n\nclass Car:\n    engine = Component('_engine')\n    wheels = Component('_wheels')\n    \n    def __init__(self):\n        self.engine = Engine()\n        self.wheels = Wheels()\n    \n    def drive(self):\n        return f\"{self.engine.start()}, {self.wheels.roll()}\"\n\ncar = Car()\nprint(car.drive())\n# Engine starting, Wheels rolling\n```\n\n---\n\n### Mixins: Advanced Patterns\n\n#### Ordered Mixins\n\n```python\nclass TimestampMixin:\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        from datetime import datetime\n        self._created = datetime.now()\n\nclass ValidationMixin:\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.validate()\n    \n    def validate(self):\n        pass\n\nclass User(ValidationMixin, TimestampMixin):\n    def __init__(self, email):\n        self.email = email\n        super().__init__()\n    \n    def validate(self):\n        if '@' not in self.email:\n            raise ValueError(\"Invalid email\")\n\n# MRO: User -> ValidationMixin -> TimestampMixin -> object\nuser = User(\"test@example.com\")\nprint(user._created)\n```\n\n---\n\n### Composition with Context Managers\n\n```python\nclass Database:\n    def __enter__(self):\n        print(\"Database connection opened\")\n        return self\n    \n    def __exit__(self, *args):\n        print(\"Database connection closed\")\n    \n    def query(self, sql):\n        return f\"Executing: {sql}\"\n\nclass Repository:\n    def __init__(self, db):\n        self.db = db\n    \n    def find_user(self, user_id):\n        return self.db.query(f\"SELECT * FROM users WHERE id={user_id}\")\n\nwith Database() as db:\n    repo = Repository(db)\n    result = repo.find_user(1)\n    print(result)\n# Output:\n# Database connection opened\n# Executing: SELECT * FROM users WHERE id=1\n# Database connection closed\n```\n\n---\n\n### Protocol Classes (PEP 544)\n\nStructural subtyping without explicit inheritance.\n\n```python\nfrom typing import Protocol\n\nclass Drawable(Protocol):\n    def draw(self) -> str:\n        ...\n\nclass Circle:\n    def draw(self) -> str:\n        return \"Drawing circle\"\n\nclass Rectangle:\n    def draw(self) -> str:\n        return \"Drawing rectangle\"\n\ndef render(shape: Drawable):\n    print(shape.draw())\n\n# No inheritance needed!\nrender(Circle())     # Works\nrender(Rectangle())  # Works\n```\n\n---\n\n### Performance Considerations\n\n#### Inheritance Overhead\n\n```python\nimport timeit\n\nclass Base:\n    def method(self):\n        return 42\n\nclass Child(Base):\n    pass\n\nclass GrandChild(Child):\n    pass\n\n# Direct call\nbase = Base()\ntime_base = timeit.timeit(lambda: base.method(), number=1000000)\n\n# Inherited call (1 level)\nchild = Child()\ntime_child = timeit.timeit(lambda: child.method(), number=1000000)\n\n# Inherited call (2 levels)\ngrand = GrandChild()\ntime_grand = timeit.timeit(lambda: grand.method(), number=1000000)\n\nprint(f\"Base: {time_base:.4f}s\")\nprint(f\"Child: {time_child:.4f}s\")\nprint(f\"GrandChild: {time_grand:.4f}s\")\n# Deep inheritance has small performance cost\n```\n\n#### Composition Performance\n\n```python\nimport timeit\n\nclass Engine:\n    def start(self):\n        return \"started\"\n\nclass Car:\n    def __init__(self):\n        self.engine = Engine()\n    \n    def start(self):\n        return self.engine.start()\n\ncar = Car()\ntime_comp = timeit.timeit(lambda: car.start(), number=1000000)\nprint(f\"Composition: {time_comp:.4f}s\")\n# Composition adds minimal overhead\n```\n\n---\n\n### SOLID Principles Applied\n\n#### Liskov Substitution Principle (LSP)\n\nSubclasses should be substitutable for their base classes.\n\n```python\n# VIOLATION of LSP\nclass Rectangle:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n\nclass Square(Rectangle):\n    def __init__(self, side):\n        super().__init__(side, side)\n    \n    def set_width(self, width):\n        self.width = width\n        self.height = width  # Breaks LSP!\n\n# BETTER: Don't inherit\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        pass\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n\nclass Square(Shape):\n    def __init__(self, side):\n        self.side = side\n    \n    def area(self):\n        return self.side ** 2\n```\n\n---\n\n### Avoiding Common Pitfalls\n\n#### Pitfall 1: Mutable Default Arguments in Inheritance\n\n```python\n# WRONG\nclass Parent:\n    def __init__(self, items=[]):\n        self.items = items\n\nclass Child(Parent):\n    pass\n\nc1 = Child()\nc2 = Child()\nc1.items.append(1)\nprint(c2.items)  # [1] - shared!\n\n# CORRECT\nclass Parent:\n    def __init__(self, items=None):\n        self.items = items if items is not None else []\n```\n\n#### Pitfall 2: Super() in Multiple Inheritance\n\n```python\n# WRONG\nclass A:\n    def __init__(self):\n        pass  # Doesn't call super()!\n\nclass B:\n    def __init__(self):\n        pass  # Doesn't call super()!\n\nclass C(A, B):\n    def __init__(self):\n        super().__init__()  # Only calls A.__init__!\n\n# CORRECT\nclass A:\n    def __init__(self):\n        super().__init__()  # Continue chain\n\nclass B:\n    def __init__(self):\n        super().__init__()  # Continue chain\n\nclass C(A, B):\n    def __init__(self):\n        super().__init__()  # Calls both A and B\n```",
  "cheatsheet": "## Inheritance & Composition: Quick Reference\n\n### Basic Inheritance Syntax\n\n```python\n# Parent class\nclass Parent:\n    def __init__(self, value):\n        self.value = value\n    \n    def method(self):\n        return \"parent\"\n\n# Child class\nclass Child(Parent):\n    def __init__(self, value, extra):\n        super().__init__(value)  # Call parent __init__\n        self.extra = extra\n    \n    def method(self):  # Override\n        return \"child\"\n    \n    def child_method(self):\n        parent_result = super().method()  # Call parent method\n        return f\"{parent_result} + child\"\n```\n\n---\n\n### Multiple Inheritance\n\n```python\nclass A:\n    def method_a(self):\n        return \"A\"\n\nclass B:\n    def method_b(self):\n        return \"B\"\n\nclass C(A, B):  # Inherits from both\n    pass\n\nc = C()\nc.method_a()  # From A\nc.method_b()  # From B\n\n# Check MRO\nprint(C.__mro__)  # (C, A, B, object)\n```\n\n---\n\n### super() Patterns\n\n```python\n# Call parent __init__\nsuper().__init__(args)\n\n# Call parent method\nsuper().method_name()\n\n# In multiple inheritance (cooperative)\nclass A:\n    def __init__(self):\n        super().__init__()  # Pass to next in MRO\n\nclass B:\n    def __init__(self):\n        super().__init__()\n\nclass C(A, B):\n    def __init__(self):\n        super().__init__()  # Calls A, then B\n```\n\n---\n\n### Abstract Base Classes (ABC)\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Interface(ABC):\n    @abstractmethod\n    def required_method(self):\n        pass\n    \n    @abstractmethod\n    def another_required(self):\n        pass\n\nclass Implementation(Interface):\n    def required_method(self):\n        return \"implemented\"\n    \n    def another_required(self):\n        return \"also implemented\"\n\n# Cannot instantiate ABC\n# obj = Interface()  # TypeError\n\n# Can instantiate implementation\nobj = Implementation()  # OK\n```\n\n---\n\n### Composition Syntax\n\n```python\n# Has-a relationship\nclass Engine:\n    def start(self):\n        return \"Engine started\"\n\nclass Car:\n    def __init__(self):\n        self.engine = Engine()  # Composition\n    \n    def start(self):\n        return self.engine.start()  # Delegate\n\ncar = Car()\ncar.start()  # Uses composed engine\n```\n\n---\n\n### Mixins\n\n```python\nclass TimestampMixin:\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        from datetime import datetime\n        self.created_at = datetime.now()\n\nclass SerializeMixin:\n    def to_dict(self):\n        return self.__dict__\n\nclass Model(TimestampMixin, SerializeMixin):\n    def __init__(self, name):\n        self.name = name\n        super().__init__()\n\nmodel = Model(\"test\")\nprint(model.to_dict())\nprint(model.created_at)\n```\n\n---\n\n### Type Checking\n\n```python\nclass Parent:\n    pass\n\nclass Child(Parent):\n    pass\n\nobj = Child()\n\n# isinstance: check object type\nisinstance(obj, Child)   # True\nisinstance(obj, Parent)  # True (inherited)\nisinstance(obj, str)     # False\n\n# issubclass: check class relationship\nissubclass(Child, Parent)  # True\nissubclass(Parent, Child)  # False\nissubclass(Child, Child)   # True\n```\n\n---\n\n### Method Resolution Order (MRO)\n\n```python\nclass A: pass\nclass B(A): pass\nclass C(A): pass\nclass D(B, C): pass\n\n# View MRO\nprint(D.__mro__)\n# (D, B, C, A, object)\n\nprint(D.mro())\n# [D, B, C, A, object]\n\n# MRO Rules:\n# 1. Child before parent\n# 2. Parent order from class definition\n# 3. Each class appears once\n```\n\n---\n\n### Decision Tree\n\n```\nChoosing Between Inheritance and Composition:\n\n1. Is it a true \"is-a\" relationship?\n   ├─ YES → Consider Inheritance\n   └─ NO → Use Composition\n\n2. Do you need ALL parent functionality?\n   ├─ YES → Inheritance might work\n   └─ NO → Use Composition\n\n3. Will behavior change at runtime?\n   ├─ YES → Use Composition\n   └─ NO → Either works\n\n4. Need loose coupling?\n   ├─ YES → Use Composition\n   └─ NO → Either works\n\nGeneral Rule: Prefer Composition over Inheritance\n```\n\n---\n\n### Common Patterns\n\n```python\n# Pattern 1: Template Method (Inheritance)\nclass Base:\n    def process(self):\n        self.step1()\n        self.step2()\n    \n    def step1(self):\n        raise NotImplementedError\n    \n    def step2(self):\n        raise NotImplementedError\n\nclass Concrete(Base):\n    def step1(self):\n        print(\"Step 1\")\n    \n    def step2(self):\n        print(\"Step 2\")\n\n# Pattern 2: Strategy (Composition)\nclass Strategy:\n    def execute(self):\n        raise NotImplementedError\n\nclass Context:\n    def __init__(self, strategy):\n        self.strategy = strategy\n    \n    def do_work(self):\n        self.strategy.execute()\n\n# Pattern 3: Mixin for cross-cutting concerns\nclass LoggingMixin:\n    def log(self, message):\n        print(f\"[{self.__class__.__name__}] {message}\")\n\nclass MyClass(LoggingMixin):\n    def do_something(self):\n        self.log(\"Doing something\")\n```\n\n---\n\n### Common Mistakes\n\n```python\n# Mistake 1: Forgetting super()\nclass Child(Parent):\n    def __init__(self, x):\n        # WRONG: self.parent_attr not initialized\n        self.x = x\n    \n    def __init__(self, x):\n        # CORRECT\n        super().__init__()\n        self.x = x\n\n# Mistake 2: Using inheritance for code reuse\n# WRONG: Car is not an Engine!\nclass Car(Engine):\n    pass\n\n# CORRECT: Car has an Engine\nclass Car:\n    def __init__(self):\n        self.engine = Engine()\n\n# Mistake 3: Deep inheritance hierarchies\n# AVOID: Hard to understand and maintain\nclass A(B(C(D(E)))):\n    pass\n\n# PREFER: Flat with composition\nclass A:\n    def __init__(self):\n        self.b = B()\n        self.c = C()\n```\n\n---\n\n### Quick Comparison Table\n\n| Feature | Inheritance | Composition |\n|---------|-------------|-------------|\n| **Relationship** | is-a | has-a |\n| **Coupling** | Tight | Loose |\n| **Flexibility** | Limited | High |\n| **Runtime change** | No | Yes |\n| **Code reuse** | Yes | Yes |\n| **Complexity** | Can grow | Manageable |\n| **Use when** | True subtype | Delegation needed |\n| **Example** | Dog is Animal | Car has Engine |\n\n---\n\n### Best Practices\n\n```python\n# ✓ Use inheritance for true is-a relationships\nclass Rectangle(Shape):  # Rectangle IS-A Shape\n    pass\n\n# ✓ Use composition for has-a relationships\nclass Car:\n    def __init__(self):\n        self.engine = Engine()  # Car HAS-AN Engine\n\n# ✓ Keep inheritance hierarchies shallow (max 2-3 levels)\nclass Base:\n    pass\n\nclass Child(Base):  # OK\n    pass\n\nclass GrandChild(Child):  # Still OK\n    pass\n\n# Avoid deeper hierarchies\n\n# ✓ Use ABCs to define contracts\nfrom abc import ABC, abstractmethod\n\nclass PaymentMethod(ABC):\n    @abstractmethod\n    def pay(self, amount):\n        pass\n\n# ✓ Use mixins for cross-cutting concerns\nclass TimestampMixin:\n    pass\n\nclass ValidateMixin:\n    pass\n\nclass User(TimestampMixin, ValidateMixin):\n    pass\n\n# ✓ Favor composition over inheritance\n# \"Composition over inheritance\" is a key design principle\n```"
}
