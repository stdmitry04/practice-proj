{
  "beginner": "## Dunder Methods: Beginner Level\n\n### What Are Dunder Methods?\n\n**Dunder** stands for \"**D**ouble **UNDER**score\" - methods with double underscores before and after their names (like `__init__`). These are also called **magic methods** or **special methods**.\n\n#### Why Use Dunder Methods?\n\n1. **Operator Overloading**: Make your objects work with `+`, `-`, `*`, etc.\n2. **Built-in Function Support**: Work with `len()`, `str()`, `repr()`, etc.\n3. **Pythonic Behavior**: Make custom classes behave like built-in types\n4. **Protocol Implementation**: Implement iteration, context management, etc.\n\n```python\n# Without dunder methods\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\np1 = Point(1, 2)\np2 = Point(3, 4)\n# p1 + p2  # TypeError: unsupported operand type(s)\nprint(p1)  # <__main__.Point object at 0x...>\n\n# With dunder methods\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __add__(self, other):\n        return Point(self.x + other.x, self.y + other.y)\n    \n    def __str__(self):\n        return f\"Point({self.x}, {self.y})\"\n\np1 = Point(1, 2)\np2 = Point(3, 4)\nprint(p1 + p2)  # Point(4, 6) - Now it works!\nprint(p1)       # Point(1, 2) - Readable output!\n```\n\n---\n\n### __init__: The Constructor\n\nCalled when creating a new object.\n\n```python\nclass Person:\n    def __init__(self, name, age):\n        print(f\"Creating person: {name}\")\n        self.name = name\n        self.age = age\n\nperson = Person(\"Alice\", 25)\n# Output: Creating person: Alice\nprint(person.name)  # \"Alice\"\n```\n\n---\n\n### __str__ and __repr__: String Representations\n\n#### __str__: User-Friendly String\n\nCalled by `str()` and `print()` - meant for end users.\n\n```python\nclass Book:\n    def __init__(self, title, author):\n        self.title = title\n        self.author = author\n    \n    def __str__(self):\n        return f\"{self.title} by {self.author}\"\n\nbook = Book(\"1984\", \"George Orwell\")\nprint(book)       # \"1984 by George Orwell\"\nprint(str(book))  # \"1984 by George Orwell\"\n```\n\n#### __repr__: Developer-Friendly String\n\nCalled by `repr()` - meant for debugging, should be unambiguous.\n\n```python\nclass Book:\n    def __init__(self, title, author):\n        self.title = title\n        self.author = author\n    \n    def __repr__(self):\n        return f\"Book(title='{self.title}', author='{self.author}')\"\n\nbook = Book(\"1984\", \"George Orwell\")\nprint(repr(book))  # Book(title='1984', author='George Orwell')\n# In REPL:\n# >>> book\n# Book(title='1984', author='George Orwell')\n```\n\n#### Best Practice: Implement Both\n\n```python\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __str__(self):\n        return f\"({self.x}, {self.y})\"  # User-friendly\n    \n    def __repr__(self):\n        return f\"Point({self.x}, {self.y})\"  # For debugging\n\npoint = Point(3, 4)\nprint(str(point))   # \"(3, 4)\"\nprint(repr(point))  # \"Point(3, 4)\"\nprint(point)        # \"(3, 4)\" - uses __str__\n```\n\n---\n\n### Comparison Operators\n\nMake objects comparable with `==`, `<`, `>`, etc.\n\n#### __eq__: Equality (==)\n\n```python\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    \n    def __eq__(self, other):\n        return self.name == other.name and self.age == other.age\n\np1 = Person(\"Alice\", 25)\np2 = Person(\"Alice\", 25)\np3 = Person(\"Bob\", 30)\n\nprint(p1 == p2)  # True\nprint(p1 == p3)  # False\n```\n\n#### __lt__, __le__, __gt__, __ge__: Ordering\n\n```python\nclass Student:\n    def __init__(self, name, grade):\n        self.name = name\n        self.grade = grade\n    \n    def __lt__(self, other):  # Less than (<)\n        return self.grade < other.grade\n    \n    def __le__(self, other):  # Less than or equal (<=)\n        return self.grade <= other.grade\n    \n    def __gt__(self, other):  # Greater than (>)\n        return self.grade > other.grade\n    \n    def __ge__(self, other):  # Greater than or equal (>=)\n        return self.grade >= other.grade\n\ns1 = Student(\"Alice\", 85)\ns2 = Student(\"Bob\", 92)\n\nprint(s1 < s2)   # True\nprint(s1 > s2)   # False\nprint(s1 <= s2)  # True\n```\n\n---\n\n### Arithmetic Operators\n\n#### Basic Arithmetic\n\n```python\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __add__(self, other):  # +\n        return Vector(self.x + other.x, self.y + other.y)\n    \n    def __sub__(self, other):  # -\n        return Vector(self.x - other.x, self.y - other.y)\n    \n    def __mul__(self, scalar):  # *\n        return Vector(self.x * scalar, self.y * scalar)\n    \n    def __str__(self):\n        return f\"Vector({self.x}, {self.y})\"\n\nv1 = Vector(1, 2)\nv2 = Vector(3, 4)\n\nprint(v1 + v2)  # Vector(4, 6)\nprint(v1 - v2)  # Vector(-2, -2)\nprint(v1 * 3)   # Vector(3, 6)\n```\n\n---\n\n### Container Methods\n\n#### __len__: Length\n\n```python\nclass Playlist:\n    def __init__(self):\n        self.songs = []\n    \n    def add_song(self, song):\n        self.songs.append(song)\n    \n    def __len__(self):\n        return len(self.songs)\n\nplaylist = Playlist()\nplaylist.add_song(\"Song 1\")\nplaylist.add_song(\"Song 2\")\n\nprint(len(playlist))  # 2\n```\n\n#### __getitem__ and __setitem__: Indexing\n\n```python\nclass CustomList:\n    def __init__(self):\n        self.items = []\n    \n    def __getitem__(self, index):  # Access: obj[index]\n        return self.items[index]\n    \n    def __setitem__(self, index, value):  # Set: obj[index] = value\n        self.items[index] = value\n    \n    def __len__(self):\n        return len(self.items)\n\nmy_list = CustomList()\nmy_list.items = [10, 20, 30]\n\nprint(my_list[0])  # 10 (uses __getitem__)\nmy_list[1] = 99    # Uses __setitem__\nprint(my_list[1])  # 99\n```\n\n---\n\n### __call__: Making Objects Callable\n\nMakes instances callable like functions.\n\n```python\nclass Multiplier:\n    def __init__(self, factor):\n        self.factor = factor\n    \n    def __call__(self, value):\n        return value * self.factor\n\ndouble = Multiplier(2)\ntriple = Multiplier(3)\n\nprint(double(5))  # 10 (calls __call__)\nprint(triple(5))  # 15\n```\n\n---\n\n### __bool__: Truthiness\n\nDefines how object evaluates in boolean context.\n\n```python\nclass ShoppingCart:\n    def __init__(self):\n        self.items = []\n    \n    def add_item(self, item):\n        self.items.append(item)\n    \n    def __bool__(self):\n        return len(self.items) > 0\n\ncart = ShoppingCart()\n\nif cart:\n    print(\"Cart has items\")\nelse:\n    print(\"Cart is empty\")  # Prints this\n\ncart.add_item(\"Apple\")\n\nif cart:\n    print(\"Cart has items\")  # Prints this\nelse:\n    print(\"Cart is empty\")\n```\n\n---\n\n### Common Beginner Patterns\n\n#### Pattern 1: Value Object\n\n```python\nclass Money:\n    def __init__(self, amount, currency=\"USD\"):\n        self.amount = amount\n        self.currency = currency\n    \n    def __add__(self, other):\n        if self.currency != other.currency:\n            raise ValueError(\"Cannot add different currencies\")\n        return Money(self.amount + other.amount, self.currency)\n    \n    def __str__(self):\n        return f\"{self.currency}{self.amount}\"\n    \n    def __repr__(self):\n        return f\"Money({self.amount}, '{self.currency}')\"\n\nm1 = Money(10)\nm2 = Money(20)\nprint(m1 + m2)  # USD30\n```\n\n#### Pattern 2: Counter\n\n```python\nclass Counter:\n    def __init__(self, start=0):\n        self.value = start\n    \n    def __iadd__(self, other):  # +=\n        self.value += other\n        return self\n    \n    def __isub__(self, other):  # -=\n        self.value -= other\n        return self\n    \n    def __str__(self):\n        return str(self.value)\n\ncounter = Counter(10)\ncounter += 5\nprint(counter)  # 15\ncounter -= 3\nprint(counter)  # 12\n```",
  "intermediate": "## Dunder Methods: Intermediate Level\n\n### Complete Comparison Protocol\n\nImplement all comparison operators efficiently.\n\n```python\nfrom functools import total_ordering\n\n@total_ordering  # Auto-generates other comparisons\nclass Version:\n    def __init__(self, major, minor, patch):\n        self.major = major\n        self.minor = minor\n        self.patch = patch\n    \n    def __eq__(self, other):\n        return (self.major, self.minor, self.patch) == \\\n               (other.major, other.minor, other.patch)\n    \n    def __lt__(self, other):\n        return (self.major, self.minor, self.patch) < \\\n               (other.major, other.minor, other.patch)\n    \n    def __str__(self):\n        return f\"{self.major}.{self.minor}.{self.patch}\"\n\nv1 = Version(1, 2, 3)\nv2 = Version(1, 3, 0)\nv3 = Version(2, 0, 0)\n\nprint(v1 < v2)   # True\nprint(v1 > v2)   # False (auto-generated)\nprint(v1 <= v2)  # True (auto-generated)\nprint(v1 >= v2)  # False (auto-generated)\nprint(v1 == v2)  # False\nprint(v1 != v2)  # True (auto-generated)\n```\n\n---\n\n### Arithmetic Protocol with Reflected Operations\n\nSupport operations like `2 * vector` (not just `vector * 2`).\n\n```python\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    # Forward operations\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y)\n    \n    def __mul__(self, scalar):\n        return Vector(self.x * scalar, self.y * scalar)\n    \n    # Reflected operations (when left operand doesn't support operation)\n    def __radd__(self, other):\n        return self.__add__(other)\n    \n    def __rmul__(self, scalar):\n        return self.__mul__(scalar)\n    \n    # In-place operations\n    def __iadd__(self, other):\n        self.x += other.x\n        self.y += other.y\n        return self\n    \n    def __imul__(self, scalar):\n        self.x *= scalar\n        self.y *= scalar\n        return self\n    \n    def __str__(self):\n        return f\"Vector({self.x}, {self.y})\"\n\nv = Vector(1, 2)\nprint(v * 3)    # Vector(3, 6) - uses __mul__\nprint(3 * v)    # Vector(3, 6) - uses __rmul__\n\nv += Vector(2, 3)  # Uses __iadd__\nprint(v)           # Vector(3, 5)\n```\n\n---\n\n### Complete Container Protocol\n\n```python\nclass FixedSizeList:\n    def __init__(self, size):\n        self._items = [None] * size\n        self._size = size\n    \n    def __len__(self):\n        \"\"\"Return length\"\"\"\n        return self._size\n    \n    def __getitem__(self, index):\n        \"\"\"Get item by index or slice\"\"\"\n        if isinstance(index, slice):\n            return [self._items[i] for i in range(*index.indices(len(self)))]\n        if index < 0:\n            index = self._size + index\n        if 0 <= index < self._size:\n            return self._items[index]\n        raise IndexError(\"Index out of range\")\n    \n    def __setitem__(self, index, value):\n        \"\"\"Set item by index\"\"\"\n        if index < 0:\n            index = self._size + index\n        if 0 <= index < self._size:\n            self._items[index] = value\n        else:\n            raise IndexError(\"Index out of range\")\n    \n    def __delitem__(self, index):\n        \"\"\"Delete item (set to None)\"\"\"\n        self._items[index] = None\n    \n    def __contains__(self, value):\n        \"\"\"Check if value in list (for 'in' operator)\"\"\"\n        return value in self._items\n    \n    def __iter__(self):\n        \"\"\"Make iterable\"\"\"\n        return iter(self._items)\n    \n    def __reversed__(self):\n        \"\"\"Support reversed()\"\"\"\n        return reversed(self._items)\n\nfixed_list = FixedSizeList(5)\nfixed_list[0] = 10\nfixed_list[1] = 20\n\nprint(len(fixed_list))      # 5\nprint(fixed_list[0])        # 10\nprint(10 in fixed_list)     # True\nprint(list(fixed_list))     # [10, 20, None, None, None]\nprint(fixed_list[1:3])      # [20, None]\n```\n\n---\n\n### Hashing and Equality\n\nMake objects hashable for use in sets and as dictionary keys.\n\n```python\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n    \n    def __eq__(self, other):\n        \"\"\"Required for hashing\"\"\"\n        if not isinstance(other, Point):\n            return False\n        return self.x == other.x and self.y == other.y\n    \n    def __hash__(self):\n        \"\"\"Make hashable\"\"\"\n        return hash((self.x, self.y))\n    \n    def __repr__(self):\n        return f\"Point({self.x}, {self.y})\"\n\n# Can use in sets and as dict keys\npoints = {Point(0, 0), Point(1, 1), Point(0, 0)}  # Duplicate removed\nprint(points)  # {Point(0, 0), Point(1, 1)}\n\npoint_names = {\n    Point(0, 0): \"origin\",\n    Point(1, 1): \"diagonal\"\n}\nprint(point_names[Point(0, 0)])  # \"origin\"\n```\n\n**Important Rules**:\n1. If `a == b`, then `hash(a) == hash(b)` must be true\n2. Hashable objects should be immutable\n3. Don't change hash after object creation\n\n---\n\n### Iteration Protocol\n\n```python\nclass Countdown:\n    def __init__(self, start):\n        self.start = start\n    \n    def __iter__(self):\n        \"\"\"Return iterator object\"\"\"\n        self.current = self.start\n        return self\n    \n    def __next__(self):\n        \"\"\"Get next value\"\"\"\n        if self.current <= 0:\n            raise StopIteration\n        self.current -= 1\n        return self.current + 1\n\nfor num in Countdown(5):\n    print(num)  # 5, 4, 3, 2, 1\n\n# Or use iter() and next()\ncountdown = Countdown(3)\nit = iter(countdown)\nprint(next(it))  # 3\nprint(next(it))  # 2\nprint(next(it))  # 1\n# print(next(it))  # StopIteration\n```\n\n---\n\n### Context Manager Protocol\n\n```python\nclass DatabaseConnection:\n    def __init__(self, host):\n        self.host = host\n        self.connected = False\n    \n    def __enter__(self):\n        \"\"\"Called when entering 'with' block\"\"\"\n        print(f\"Connecting to {self.host}\")\n        self.connected = True\n        return self  # Return value bound to 'as' variable\n    \n    def __exit__(self, exc_type, exc_value, traceback):\n        \"\"\"Called when exiting 'with' block\"\"\"\n        print(f\"Disconnecting from {self.host}\")\n        self.connected = False\n        # Return False to propagate exceptions\n        # Return True to suppress exceptions\n        return False\n    \n    def query(self, sql):\n        if not self.connected:\n            raise RuntimeError(\"Not connected\")\n        print(f\"Executing: {sql}\")\n        return []\n\nwith DatabaseConnection(\"localhost\") as db:\n    db.query(\"SELECT * FROM users\")\n# Output:\n# Connecting to localhost\n# Executing: SELECT * FROM users\n# Disconnecting from localhost\n```\n\n---\n\n### Attribute Access Control\n\n```python\nclass ProtectedAttributes:\n    def __init__(self):\n        self._data = {}\n    \n    def __getattr__(self, name):\n        \"\"\"Called when attribute not found normally\"\"\"\n        print(f\"Getting {name}\")\n        return self._data.get(name)\n    \n    def __setattr__(self, name, value):\n        \"\"\"Called on all attribute assignments\"\"\"\n        if name == \"_data\":\n            # Allow setting _data directly\n            object.__setattr__(self, name, value)\n        else:\n            print(f\"Setting {name} = {value}\")\n            self._data[name] = value\n    \n    def __delattr__(self, name):\n        \"\"\"Called when deleting attribute\"\"\"\n        print(f\"Deleting {name}\")\n        if name in self._data:\n            del self._data[name]\n\nobj = ProtectedAttributes()\nobj.x = 10      # Setting x = 10\nprint(obj.x)    # Getting x -> 10\ndel obj.x       # Deleting x\n```\n\n---\n\n### Descriptor Protocol\n\n```python\nclass PositiveNumber:\n    \"\"\"Descriptor that ensures value is positive\"\"\"\n    \n    def __init__(self, name):\n        self.name = name\n    \n    def __get__(self, obj, objtype=None):\n        \"\"\"Get attribute value\"\"\"\n        if obj is None:\n            return self\n        return obj.__dict__.get(self.name, 0)\n    \n    def __set__(self, obj, value):\n        \"\"\"Set attribute value with validation\"\"\"\n        if value < 0:\n            raise ValueError(f\"{self.name} must be positive\")\n        obj.__dict__[self.name] = value\n    \n    def __delete__(self, obj):\n        \"\"\"Delete attribute\"\"\"\n        del obj.__dict__[self.name]\n\nclass BankAccount:\n    balance = PositiveNumber('balance')\n    \n    def __init__(self, balance):\n        self.balance = balance\n\naccount = BankAccount(100)\nprint(account.balance)  # 100\n\naccount.balance = 200\nprint(account.balance)  # 200\n\n# account.balance = -50  # ValueError: balance must be positive\n```",
  "advanced": "## Dunder Methods: Advanced Level\n\n### __new__ vs __init__\n\n`__new__` creates the instance, `__init__` initializes it.\n\n```python\nclass Singleton:\n    _instance = None\n    \n    def __new__(cls, *args, **kwargs):\n        \"\"\"Called before __init__, creates instance\"\"\"\n        if cls._instance is None:\n            print(\"Creating new instance\")\n            cls._instance = super().__new__(cls)\n        return cls._instance\n    \n    def __init__(self, value):\n        \"\"\"Called after __new__, initializes instance\"\"\"\n        print(f\"Initializing with value: {value}\")\n        self.value = value\n\n# First creation\ns1 = Singleton(\"first\")\n# Output:\n# Creating new instance\n# Initializing with value: first\n\n# Second creation (same instance!)\ns2 = Singleton(\"second\")\n# Output:\n# Initializing with value: second  (no \"Creating new instance\")\n\nprint(s1 is s2)  # True\nprint(s1.value)  # \"second\" (overwritten!)\n```\n\n---\n\n### Advanced Descriptors\n\n```python\nclass TypedProperty:\n    \"\"\"Descriptor with type checking\"\"\"\n    \n    def __init__(self, name, expected_type):\n        self.name = name\n        self.expected_type = expected_type\n    \n    def __set_name__(self, owner, name):\n        \"\"\"Called when descriptor is assigned to class attribute\"\"\"\n        self.public_name = name\n        self.private_name = f'_{name}'\n    \n    def __get__(self, obj, objtype=None):\n        if obj is None:\n            return self\n        return getattr(obj, self.private_name, None)\n    \n    def __set__(self, obj, value):\n        if not isinstance(value, self.expected_type):\n            raise TypeError(\n                f\"{self.public_name} must be {self.expected_type.__name__}\"\n            )\n        setattr(obj, self.private_name, value)\n\nclass Person:\n    name = TypedProperty('name', str)\n    age = TypedProperty('age', int)\n    \n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\nperson = Person(\"Alice\", 25)\nprint(person.name)  # \"Alice\"\n\n# person.name = 123  # TypeError: name must be str\n# person.age = \"25\"  # TypeError: age must be int\n```\n\n---\n\n### __getattribute__ vs __getattr__\n\n```python\nclass TrackedAttributes:\n    def __init__(self):\n        object.__setattr__(self, '_data', {})\n        object.__setattr__(self, '_accessed', set())\n    \n    def __getattribute__(self, name):\n        \"\"\"Called for EVERY attribute access\"\"\"\n        if name in ('_data', '_accessed'):\n            return object.__getattribute__(self, name)\n        \n        # Track access\n        accessed = object.__getattribute__(self, '_accessed')\n        accessed.add(name)\n        \n        # Get value\n        data = object.__getattribute__(self, '_data')\n        if name in data:\n            return data[name]\n        \n        # Fall back to __getattr__\n        return object.__getattribute__(self, name)\n    \n    def __getattr__(self, name):\n        \"\"\"Called only when attribute not found\"\"\"\n        print(f\"Attribute {name} not found\")\n        return None\n    \n    def __setattr__(self, name, value):\n        self._data[name] = value\n\nobj = TrackedAttributes()\nobj.x = 10\nobj.y = 20\nprint(obj.x)  # 10\nprint(obj.z)  # Attribute z not found -> None\nprint(obj._accessed)  # {'x', 'y', 'z'}\n```\n\n---\n\n### Advanced Numeric Protocol\n\n```python\nclass ComplexNumber:\n    def __init__(self, real, imag):\n        self.real = real\n        self.imag = imag\n    \n    # Unary operators\n    def __pos__(self):\n        return ComplexNumber(+self.real, +self.imag)\n    \n    def __neg__(self):\n        return ComplexNumber(-self.real, -self.imag)\n    \n    def __abs__(self):\n        return (self.real**2 + self.imag**2)**0.5\n    \n    def __invert__(self):  # ~\n        return ComplexNumber(self.real, -self.imag)\n    \n    # Binary operators\n    def __add__(self, other):\n        return ComplexNumber(\n            self.real + other.real,\n            self.imag + other.imag\n        )\n    \n    def __sub__(self, other):\n        return ComplexNumber(\n            self.real - other.real,\n            self.imag - other.imag\n        )\n    \n    def __mul__(self, other):\n        return ComplexNumber(\n            self.real * other.real - self.imag * other.imag,\n            self.real * other.imag + self.imag * other.real\n        )\n    \n    def __truediv__(self, other):\n        denominator = other.real**2 + other.imag**2\n        return ComplexNumber(\n            (self.real * other.real + self.imag * other.imag) / denominator,\n            (self.imag * other.real - self.real * other.imag) / denominator\n        )\n    \n    def __pow__(self, power):\n        # Simplified power implementation\n        magnitude = abs(self) ** power\n        return ComplexNumber(magnitude * self.real, magnitude * self.imag)\n    \n    def __repr__(self):\n        return f\"ComplexNumber({self.real}, {self.imag})\"\n\nc1 = ComplexNumber(3, 4)\nprint(abs(c1))    # 5.0\nprint(-c1)        # ComplexNumber(-3, -4)\nprint(~c1)        # ComplexNumber(3, -4)\n```\n\n---\n\n### Context Manager with Exception Handling\n\n```python\nclass Transaction:\n    def __init__(self, connection):\n        self.connection = connection\n        self.transaction_started = False\n    \n    def __enter__(self):\n        print(\"BEGIN TRANSACTION\")\n        self.transaction_started = True\n        return self\n    \n    def __exit__(self, exc_type, exc_value, traceback):\n        if exc_type is None:\n            # No exception - commit\n            print(\"COMMIT\")\n            self.transaction_started = False\n            return True\n        else:\n            # Exception occurred - rollback\n            print(f\"ROLLBACK due to {exc_type.__name__}: {exc_value}\")\n            self.transaction_started = False\n            return False  # Re-raise exception\n    \n    def execute(self, sql):\n        if not self.transaction_started:\n            raise RuntimeError(\"No active transaction\")\n        print(f\"EXECUTE: {sql}\")\n\n# Success case\nwith Transaction(\"db\") as txn:\n    txn.execute(\"INSERT INTO users VALUES (1, 'Alice')\")\n    txn.execute(\"INSERT INTO users VALUES (2, 'Bob')\")\n# Output:\n# BEGIN TRANSACTION\n# EXECUTE: INSERT INTO users VALUES (1, 'Alice')\n# EXECUTE: INSERT INTO users VALUES (2, 'Bob')\n# COMMIT\n\n# Error case\ntry:\n    with Transaction(\"db\") as txn:\n        txn.execute(\"INSERT INTO users VALUES (3, 'Charlie')\")\n        raise ValueError(\"Something went wrong\")\n        txn.execute(\"This won't execute\")\nexcept ValueError:\n    pass\n# Output:\n# BEGIN TRANSACTION\n# EXECUTE: INSERT INTO users VALUES (3, 'Charlie')\n# ROLLBACK due to ValueError: Something went wrong\n```\n\n---\n\n### Pickle Protocol\n\n```python\nclass CustomData:\n    def __init__(self, data, metadata):\n        self.data = data\n        self.metadata = metadata\n        self._cache = {}  # Don't want to pickle this\n    \n    def __getstate__(self):\n        \"\"\"Return state for pickling\"\"\"\n        state = self.__dict__.copy()\n        # Remove unpicklable or unwanted attributes\n        del state['_cache']\n        return state\n    \n    def __setstate__(self, state):\n        \"\"\"Restore state from pickle\"\"\"\n        self.__dict__.update(state)\n        self._cache = {}  # Recreate cache\n\nimport pickle\n\nobj = CustomData([1, 2, 3], {\"version\": 1})\nobj._cache['key'] = 'value'\n\n# Pickle\npickled = pickle.dumps(obj)\n\n# Unpickle\nrestored = pickle.loads(pickled)\nprint(restored.data)      # [1, 2, 3]\nprint(restored.metadata)  # {'version': 1}\nprint(restored._cache)    # {} (recreated empty)\n```\n\n---\n\n### Performance Optimization with __slots__\n\n```python\nimport sys\n\n# Regular class\nclass RegularPoint:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n# Optimized with __slots__\nclass OptimizedPoint:\n    __slots__ = ['x', 'y']  # Only allow these attributes\n    \n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nregular = RegularPoint(1, 2)\noptimized = OptimizedPoint(1, 2)\n\nprint(f\"Regular: {sys.getsizeof(regular)} bytes\")\nprint(f\"Optimized: {sys.getsizeof(optimized)} bytes\")\n# Optimized uses ~30-40% less memory\n\n# Slots prevent dynamic attributes\n# regular.z = 3     # OK\n# optimized.z = 3   # AttributeError\n```\n\n---\n\n### Advanced Pattern: Immutable Class\n\n```python\nclass ImmutablePoint:\n    __slots__ = ['_x', '_y']\n    \n    def __init__(self, x, y):\n        object.__setattr__(self, '_x', x)\n        object.__setattr__(self, '_y', y)\n    \n    @property\n    def x(self):\n        return self._x\n    \n    @property\n    def y(self):\n        return self._y\n    \n    def __setattr__(self, name, value):\n        raise AttributeError(\"Cannot modify immutable object\")\n    \n    def __delattr__(self, name):\n        raise AttributeError(\"Cannot delete from immutable object\")\n    \n    def __hash__(self):\n        return hash((self._x, self._y))\n    \n    def __eq__(self, other):\n        return isinstance(other, ImmutablePoint) and \\\n               self._x == other._x and self._y == other._y\n    \n    def __repr__(self):\n        return f\"ImmutablePoint({self._x}, {self._y})\"\n\npoint = ImmutablePoint(3, 4)\nprint(point.x)  # 3\n\n# point.x = 10  # AttributeError\n# del point.x   # AttributeError\n\n# Can use in sets\npoints = {ImmutablePoint(0, 0), ImmutablePoint(1, 1)}\n```",
  "cheatsheet": "## Dunder Methods: Quick Reference\n\n### Initialization and Representation\n\n```python\nclass MyClass:\n    def __init__(self, value):\n        \"\"\"Constructor\"\"\"\n        self.value = value\n    \n    def __str__(self):\n        \"\"\"User-friendly string (for print)\"\"\"\n        return f\"MyClass with value {self.value}\"\n    \n    def __repr__(self):\n        \"\"\"Developer-friendly string (for debugging)\"\"\"\n        return f\"MyClass({self.value})\"\n```\n\n### Comparison Operators\n\n```python\ndef __eq__(self, other):   # ==\ndef __ne__(self, other):   # !=\ndef __lt__(self, other):   # <\ndef __le__(self, other):   # <=\ndef __gt__(self, other):   # >\ndef __ge__(self, other):   # >=\n```\n\n### Arithmetic Operators\n\n```python\n# Binary\ndef __add__(self, other):      # +\ndef __sub__(self, other):      # -\ndef __mul__(self, other):      # *\ndef __truediv__(self, other):  # /\ndef __floordiv__(self, other): # //\ndef __mod__(self, other):      # %\ndef __pow__(self, other):      # **\n\n# Reflected (when left operand doesn't support)\ndef __radd__(self, other):     # other + self\ndef __rsub__(self, other):     # other - self\n# ... etc.\n\n# In-place\ndef __iadd__(self, other):     # +=\ndef __isub__(self, other):     # -=\n# ... etc.\n\n# Unary\ndef __neg__(self):             # -self\ndef __pos__(self):             # +self\ndef __abs__(self):             # abs(self)\n```\n\n### Container Methods\n\n```python\ndef __len__(self):                 # len(obj)\ndef __getitem__(self, key):        # obj[key]\ndef __setitem__(self, key, value): # obj[key] = value\ndef __delitem__(self, key):        # del obj[key]\ndef __contains__(self, item):      # item in obj\ndef __iter__(self):                # for x in obj\ndef __reversed__(self):            # reversed(obj)\n```\n\n### Callable and Context Manager\n\n```python\ndef __call__(self, *args, **kwargs):  # obj()\ndef __enter__(self):                   # with obj:\ndef __exit__(self, exc_type, exc_val, exc_tb):  # End of with\n```\n\n### Attribute Access\n\n```python\ndef __getattr__(self, name):           # obj.name (if not found)\ndef __setattr__(self, name, value):    # obj.name = value\ndef __delattr__(self, name):           # del obj.name\ndef __getattribute__(self, name):      # obj.name (always called)\n```\n\n### Descriptor Protocol\n\n```python\ndef __get__(self, obj, objtype=None):  # obj.desc\ndef __set__(self, obj, value):         # obj.desc = value\ndef __delete__(self, obj):             # del obj.desc\ndef __set_name__(self, owner, name):   # Called when assigned to class\n```\n\n### Hashing\n\n```python\ndef __hash__(self):  # hash(obj), for dict keys and sets\ndef __bool__(self):  # bool(obj), if obj:\n```\n\n### String Conversion\n\n```python\ndef __str__(self):   # str(obj), print(obj)\ndef __repr__(self):  # repr(obj), obj in REPL\ndef __bytes__(self): # bytes(obj)\ndef __format__(self, format_spec):  # f\"{obj:spec}\"\n```\n\n### Object Creation\n\n```python\ndef __new__(cls, *args, **kwargs):  # Create instance (before __init__)\ndef __init__(self, *args, **kwargs): # Initialize instance\ndef __del__(self):                   # Destructor (rarely used)\n```\n\n### Common Patterns\n\n#### Pattern 1: Comparable Value Object\n\n```python\nfrom functools import total_ordering\n\n@total_ordering\nclass Version:\n    def __init__(self, major, minor):\n        self.major = major\n        self.minor = minor\n    \n    def __eq__(self, other):\n        return (self.major, self.minor) == (other.major, other.minor)\n    \n    def __lt__(self, other):\n        return (self.major, self.minor) < (other.major, other.minor)\n    \n    def __repr__(self):\n        return f\"Version({self.major}.{self.minor})\"\n```\n\n#### Pattern 2: Container\n\n```python\nclass Container:\n    def __init__(self):\n        self.items = []\n    \n    def __len__(self):\n        return len(self.items)\n    \n    def __getitem__(self, index):\n        return self.items[index]\n    \n    def __setitem__(self, index, value):\n        self.items[index] = value\n    \n    def __contains__(self, item):\n        return item in self.items\n    \n    def __iter__(self):\n        return iter(self.items)\n```\n\n#### Pattern 3: Context Manager\n\n```python\nclass Resource:\n    def __enter__(self):\n        print(\"Acquiring resource\")\n        return self\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        print(\"Releasing resource\")\n        return False  # Don't suppress exceptions\n\nwith Resource() as r:\n    # Use resource\n    pass\n```\n\n#### Pattern 4: Callable Object\n\n```python\nclass Multiplier:\n    def __init__(self, factor):\n        self.factor = factor\n    \n    def __call__(self, value):\n        return value * self.factor\n\ndouble = Multiplier(2)\nprint(double(5))  # 10\n```\n\n### Quick Decision Guide\n\n```\nNeed to...                          Use...\n─────────────────────────────────────────────────────\nCustom initialization               __init__\nString for users                    __str__\nString for debugging                __repr__\nMath operations (+, -, *, /)        __add__, __sub__, etc.\nComparisons (==, <, >, etc.)        __eq__, __lt__, etc.\nIndexing (obj[key])                 __getitem__, __setitem__\nLength (len(obj))                   __len__\nIteration (for x in obj)            __iter__, __next__\nMembership (x in obj)               __contains__\nCallable (obj())                    __call__\nContext manager (with obj)          __enter__, __exit__\nHash for dict key                   __hash__ + __eq__\nAttribute access control            __getattr__, __setattr__\n```\n\n### Common Mistakes\n\n```python\n# ✗ __str__ without __repr__\nclass Bad:\n    def __str__(self):\n        return \"Bad object\"\n# Missing __repr__ for debugging\n\n# ✓ Both implemented\nclass Good:\n    def __str__(self):\n        return \"Good object\"\n    def __repr__(self):\n        return \"Good()\"\n\n# ✗ __eq__ without __hash__\nclass Bad:\n    def __eq__(self, other):\n        return True\n# Can't use in sets or as dict key\n\n# ✓ Both implemented\nclass Good:\n    def __eq__(self, other):\n        return self.value == other.value\n    def __hash__(self):\n        return hash(self.value)\n\n# ✗ Modifying in __hash__\nclass Bad:\n    def __hash__(self):\n        self.x += 1  # BAD!\n        return hash(self.x)\n\n# ✓ __hash__ is pure\nclass Good:\n    def __hash__(self):\n        return hash((self.x, self.y))\n```\n\n### Best Practices\n\n```python\n# ✓ Always implement __repr__\ndef __repr__(self):\n    return f\"{self.__class__.__name__}({self.value})\"\n\n# ✓ __str__ for users, __repr__ for developers\ndef __str__(self):\n    return f\"Value: {self.value}\"  # Friendly\n\ndef __repr__(self):\n    return f\"MyClass({self.value})\"  # Unambiguous\n\n# ✓ Return NotImplemented for unsupported operations\ndef __add__(self, other):\n    if not isinstance(other, MyClass):\n        return NotImplemented\n    return MyClass(self.value + other.value)\n\n# ✓ Use @total_ordering for comparison methods\nfrom functools import total_ordering\n\n@total_ordering\nclass MyClass:\n    def __eq__(self, other):\n        return self.value == other.value\n    \n    def __lt__(self, other):\n        return self.value < other.value\n    # Other comparisons auto-generated\n```"
}
